/*
 * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2014, 2020 Red Hat Inc. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

#include <stdio.h>
#include <sys/types.h>

#include "precompiled.hpp"
#include "asm/assembler.hpp"
#include "asm/assembler.inline.hpp"
#include "interpreter/interpreter.hpp"

#ifndef PRODUCT
const uintptr_t Assembler::asm_bp = 0x00007fffee09ac88;
#endif

#include "compiler/disassembler.hpp"
#include "memory/resourceArea.hpp"
#include "runtime/interfaceSupport.inline.hpp"
#include "runtime/sharedRuntime.hpp"
#include "immediate_aarch64.hpp"

extern "C" void entry(CodeBuffer *cb);

#define __ _masm.
#ifdef PRODUCT
#define BLOCK_COMMENT(str) /* nothing */
#else
#define BLOCK_COMMENT(str) block_comment(str)
#endif

#define BIND(label) bind(label); __ BLOCK_COMMENT(#label ":")

static float unpack(unsigned value);

short Assembler::SIMD_Size_in_bytes[] = {
  // T8B, T16B, T4H, T8H, T2S, T4S, T1D, T2D, T1Q
       8,   16,   8,  16,   8,  16,   8,  16,  16
};

#ifdef ASSERT
static void asm_check(const unsigned int *insns, const unsigned int *insns1, size_t len) {
    bool ok = true;
    for (unsigned int i = 0; i < len; i++) {
      if (insns[i] != insns1[i]) {
        ok = false;
        printf("Ours:\n");
        Disassembler::decode((address)&insns1[i], (address)&insns1[i+1]);
        printf("Theirs:\n");
        Disassembler::decode((address)&insns[i], (address)&insns[i+1]);
        printf("\n");
      }
    }
    assert(ok, "Assembler smoke test failed");
  }

void entry(CodeBuffer *cb) {

  // {
  //   for (int i = 0; i < 256; i+=16)
  //     {
  //    printf("\"%20.20g\", ", unpack(i));
  //    printf("\"%20.20g\", ", unpack(i+1));
  //     }
  //   printf("\n");
  // }

  Assembler _masm(cb);
  address entry = __ pc();

  // Smoke test for assembler

// BEGIN  Generated code -- do not edit
// Generated by aarch64-asmtest.py
    Label back, forth;
    __ bind(back);

// ArithOp
    __ add(r25, r22, r12, Assembler::LSL, 32);         //	add	x25, x22, x12, LSL #32
    __ sub(r11, r23, r8, Assembler::LSR, 37);          //	sub	x11, x23, x8, LSR #37
    __ adds(r27, r14, r8, Assembler::ASR, 39);         //	adds	x27, x14, x8, ASR #39
    __ subs(r7, r27, r29, Assembler::ASR, 57);         //	subs	x7, x27, x29, ASR #57
    __ addw(r8, r22, r27, Assembler::ASR, 15);         //	add	w8, w22, w27, ASR #15
    __ subw(r2, r12, r17, Assembler::ASR, 30);         //	sub	w2, w12, w17, ASR #30
    __ addsw(r13, r26, r7, Assembler::ASR, 17);        //	adds	w13, w26, w7, ASR #17
    __ subsw(r0, r21, r11, Assembler::ASR, 21);        //	subs	w0, w21, w11, ASR #21
    __ andr(r0, r14, r26, Assembler::LSL, 20);         //	and	x0, x14, x26, LSL #20
    __ orr(r26, r5, r16, Assembler::LSL, 61);          //	orr	x26, x5, x16, LSL #61
    __ eor(r24, r12, r2, Assembler::LSL, 32);          //	eor	x24, x12, x2, LSL #32
    __ ands(r28, r3, r15, Assembler::ASR, 35);         //	ands	x28, x3, x15, ASR #35
    __ andw(r24, r15, r28, Assembler::LSR, 18);        //	and	w24, w15, w28, LSR #18
    __ orrw(r12, r17, r11, Assembler::LSR, 9);         //	orr	w12, w17, w11, LSR #9
    __ eorw(r5, r5, r17, Assembler::LSR, 15);          //	eor	w5, w5, w17, LSR #15
    __ andsw(r2, r22, r26, Assembler::ASR, 26);        //	ands	w2, w22, w26, ASR #26
    __ bic(r27, r27, r15, Assembler::LSR, 45);         //	bic	x27, x27, x15, LSR #45
    __ orn(r7, r24, r25, Assembler::ASR, 37);          //	orn	x7, x24, x25, ASR #37
    __ eon(r28, r16, r13, Assembler::LSR, 63);         //	eon	x28, x16, x13, LSR #63
    __ bics(r27, r24, r2, Assembler::LSR, 31);         //	bics	x27, x24, x2, LSR #31
    __ bicw(r19, r25, r7, Assembler::ASR, 3);          //	bic	w19, w25, w7, ASR #3
    __ ornw(r6, r24, r9, Assembler::ASR, 3);           //	orn	w6, w24, w9, ASR #3
    __ eonw(r4, r21, r1, Assembler::LSR, 29);          //	eon	w4, w21, w1, LSR #29
    __ bicsw(r15, r20, r0, Assembler::LSR, 19);        //	bics	w15, w20, w0, LSR #19

// AddSubImmOp
    __ addw(r16, r11, 379u);                           //	add	w16, w11, #379
    __ addsw(r29, r1, 22u);                            //	adds	w29, w1, #22
    __ subw(r28, r5, 126u);                            //	sub	w28, w5, #126
    __ subsw(r6, r24, 960u);                           //	subs	w6, w24, #960
    __ add(r0, r12, 104u);                             //	add	x0, x12, #104
    __ adds(r7, r6, 663u);                             //	adds	x7, x6, #663
    __ sub(r10, r5, 516u);                             //	sub	x10, x5, #516
    __ subs(r1, r2, 1012u);                            //	subs	x1, x2, #1012

// LogicalImmOp
    __ andw(r5, r10, 4294049777ull);                   //	and	w5, w10, #0xfff1fff1
    __ orrw(r27, r4, 4294966791ull);                   //	orr	w27, w4, #0xfffffe07
    __ eorw(r1, r20, 134217216ull);                    //	eor	w1, w20, #0x7fffe00
    __ andsw(r7, r17, 1048576ull);                     //	ands	w7, w17, #0x100000
    __ andr(r13, r11, 9223372036854775808ull);         //	and	x13, x11, #0x8000000000000000
    __ orr(r9, r10, 562675075514368ull);               //	orr	x9, x10, #0x1ffc000000000
    __ eor(r16, r0, 18014398509481728ull);             //	eor	x16, x0, #0x3fffffffffff00
    __ ands(r1, r8, 18446744073705357315ull);          //	ands	x1, x8, #0xffffffffffc00003

// AbsOp
    __ b(__ pc());                                     //	b	.
    __ b(back);                                        //	b	back
    __ b(forth);                                       //	b	forth
    __ bl(__ pc());                                    //	bl	.
    __ bl(back);                                       //	bl	back
    __ bl(forth);                                      //	bl	forth

// RegAndAbsOp
    __ cbzw(r10, __ pc());                             //	cbz	w10, .
    __ cbzw(r10, back);                                //	cbz	w10, back
    __ cbzw(r10, forth);                               //	cbz	w10, forth
    __ cbnzw(r8, __ pc());                             //	cbnz	w8, .
    __ cbnzw(r8, back);                                //	cbnz	w8, back
    __ cbnzw(r8, forth);                               //	cbnz	w8, forth
    __ cbz(r10, __ pc());                              //	cbz	x10, .
    __ cbz(r10, back);                                 //	cbz	x10, back
    __ cbz(r10, forth);                                //	cbz	x10, forth
    __ cbnz(r28, __ pc());                             //	cbnz	x28, .
    __ cbnz(r28, back);                                //	cbnz	x28, back
    __ cbnz(r28, forth);                               //	cbnz	x28, forth
    __ adr(r19, __ pc());                              //	adr	x19, .
    __ adr(r19, back);                                 //	adr	x19, back
    __ adr(r19, forth);                                //	adr	x19, forth
    __ _adrp(r19, __ pc());                            //	adrp	x19, .

// RegImmAbsOp
    __ tbz(r21, 6, __ pc());                           //	tbz	x21, #6, .
    __ tbz(r21, 6, back);                              //	tbz	x21, #6, back
    __ tbz(r21, 6, forth);                             //	tbz	x21, #6, forth
    __ tbnz(r12, 11, __ pc());                         //	tbnz	x12, #11, .
    __ tbnz(r12, 11, back);                            //	tbnz	x12, #11, back
    __ tbnz(r12, 11, forth);                           //	tbnz	x12, #11, forth

// MoveWideImmOp
    __ movnw(r0, 6301, 0);                             //	movn	w0, #6301, lsl 0
    __ movzw(r6, 20886, 0);                            //	movz	w6, #20886, lsl 0
    __ movkw(r26, 18617, 0);                           //	movk	w26, #18617, lsl 0
    __ movn(r11, 22998, 16);                           //	movn	x11, #22998, lsl 16
    __ movz(r20, 1532, 16);                            //	movz	x20, #1532, lsl 16
    __ movk(r7, 5167, 32);                             //	movk	x7, #5167, lsl 32

// BitfieldOp
    __ sbfm(r14, r16, 24, 28);                         //	sbfm	x14, x16, #24, #28
    __ bfmw(r14, r9, 14, 25);                          //	bfm	w14, w9, #14, #25
    __ ubfmw(r26, r24, 6, 31);                         //	ubfm	w26, w24, #6, #31
    __ sbfm(r19, r2, 23, 31);                          //	sbfm	x19, x2, #23, #31
    __ bfm(r11, r20, 10, 6);                           //	bfm	x11, x20, #10, #6
    __ ubfm(r21, r0, 26, 16);                          //	ubfm	x21, x0, #26, #16

// ExtractOp
    __ extrw(r2, r3, r19, 27);                         //	extr	w2, w3, w19, #27
    __ extr(r8, r29, r2, 54);                          //	extr	x8, x29, x2, #54

// CondBranchOp
    __ br(Assembler::EQ, __ pc());                     //	b.EQ	.
    __ br(Assembler::EQ, back);                        //	b.EQ	back
    __ br(Assembler::EQ, forth);                       //	b.EQ	forth
    __ br(Assembler::NE, __ pc());                     //	b.NE	.
    __ br(Assembler::NE, back);                        //	b.NE	back
    __ br(Assembler::NE, forth);                       //	b.NE	forth
    __ br(Assembler::HS, __ pc());                     //	b.HS	.
    __ br(Assembler::HS, back);                        //	b.HS	back
    __ br(Assembler::HS, forth);                       //	b.HS	forth
    __ br(Assembler::CS, __ pc());                     //	b.CS	.
    __ br(Assembler::CS, back);                        //	b.CS	back
    __ br(Assembler::CS, forth);                       //	b.CS	forth
    __ br(Assembler::LO, __ pc());                     //	b.LO	.
    __ br(Assembler::LO, back);                        //	b.LO	back
    __ br(Assembler::LO, forth);                       //	b.LO	forth
    __ br(Assembler::CC, __ pc());                     //	b.CC	.
    __ br(Assembler::CC, back);                        //	b.CC	back
    __ br(Assembler::CC, forth);                       //	b.CC	forth
    __ br(Assembler::MI, __ pc());                     //	b.MI	.
    __ br(Assembler::MI, back);                        //	b.MI	back
    __ br(Assembler::MI, forth);                       //	b.MI	forth
    __ br(Assembler::PL, __ pc());                     //	b.PL	.
    __ br(Assembler::PL, back);                        //	b.PL	back
    __ br(Assembler::PL, forth);                       //	b.PL	forth
    __ br(Assembler::VS, __ pc());                     //	b.VS	.
    __ br(Assembler::VS, back);                        //	b.VS	back
    __ br(Assembler::VS, forth);                       //	b.VS	forth
    __ br(Assembler::VC, __ pc());                     //	b.VC	.
    __ br(Assembler::VC, back);                        //	b.VC	back
    __ br(Assembler::VC, forth);                       //	b.VC	forth
    __ br(Assembler::HI, __ pc());                     //	b.HI	.
    __ br(Assembler::HI, back);                        //	b.HI	back
    __ br(Assembler::HI, forth);                       //	b.HI	forth
    __ br(Assembler::LS, __ pc());                     //	b.LS	.
    __ br(Assembler::LS, back);                        //	b.LS	back
    __ br(Assembler::LS, forth);                       //	b.LS	forth
    __ br(Assembler::GE, __ pc());                     //	b.GE	.
    __ br(Assembler::GE, back);                        //	b.GE	back
    __ br(Assembler::GE, forth);                       //	b.GE	forth
    __ br(Assembler::LT, __ pc());                     //	b.LT	.
    __ br(Assembler::LT, back);                        //	b.LT	back
    __ br(Assembler::LT, forth);                       //	b.LT	forth
    __ br(Assembler::GT, __ pc());                     //	b.GT	.
    __ br(Assembler::GT, back);                        //	b.GT	back
    __ br(Assembler::GT, forth);                       //	b.GT	forth
    __ br(Assembler::LE, __ pc());                     //	b.LE	.
    __ br(Assembler::LE, back);                        //	b.LE	back
    __ br(Assembler::LE, forth);                       //	b.LE	forth
    __ br(Assembler::AL, __ pc());                     //	b.AL	.
    __ br(Assembler::AL, back);                        //	b.AL	back
    __ br(Assembler::AL, forth);                       //	b.AL	forth
    __ br(Assembler::NV, __ pc());                     //	b.NV	.
    __ br(Assembler::NV, back);                        //	b.NV	back
    __ br(Assembler::NV, forth);                       //	b.NV	forth

// ImmOp
    __ svc(12999);                                     //	svc	#12999
    __ hvc(2665);                                      //	hvc	#2665
    __ smc(9002);                                      //	smc	#9002
    __ brk(14843);                                     //	brk	#14843
    __ hlt(25964);                                     //	hlt	#25964

// Op
    __ nop();                                          //	nop	
    __ eret();                                         //	eret	
    __ drps();                                         //	drps	
    __ isb();                                          //	isb	

// SystemOp
    __ dsb(Assembler::ST);                             //	dsb	ST
    __ dmb(Assembler::OSHST);                          //	dmb	OSHST

// OneRegOp
    __ br(r15);                                        //	br	x15
    __ blr(r19);                                       //	blr	x19

// LoadStoreExclusiveOp
    __ stxr(r10, r26, r8);                             //	stxr	w10, x26, [x8]
    __ stlxr(r0, r1, r20);                             //	stlxr	w0, x1, [x20]
    __ ldxr(r16, r28);                                 //	ldxr	x16, [x28]
    __ ldaxr(r28, r27);                                //	ldaxr	x28, [x27]
    __ stlr(r1, r22);                                  //	stlr	x1, [x22]
    __ ldar(r21, r20);                                 //	ldar	x21, [x20]

// LoadStoreExclusiveOp
    __ stxrw(r21, r27, r19);                           //	stxr	w21, w27, [x19]
    __ stlxrw(r10, r15, r6);                           //	stlxr	w10, w15, [x6]
    __ ldxrw(r17, r0);                                 //	ldxr	w17, [x0]
    __ ldaxrw(r4, r9);                                 //	ldaxr	w4, [x9]
    __ stlrw(r23, r21);                                //	stlr	w23, [x21]
    __ ldarw(r9, r17);                                 //	ldar	w9, [x17]

// LoadStoreExclusiveOp
    __ stxrh(r1, r4, r29);                             //	stxrh	w1, w4, [x29]
    __ stlxrh(r8, r11, r15);                           //	stlxrh	w8, w11, [x15]
    __ ldxrh(r8, r13);                                 //	ldxrh	w8, [x13]
    __ ldaxrh(r6, r1);                                 //	ldaxrh	w6, [x1]
    __ stlrh(r5, r15);                                 //	stlrh	w5, [x15]
    __ ldarh(r2, r11);                                 //	ldarh	w2, [x11]

// LoadStoreExclusiveOp
    __ stxrb(r9, r12, r2);                             //	stxrb	w9, w12, [x2]
    __ stlxrb(r27, r13, r25);                          //	stlxrb	w27, w13, [x25]
    __ ldxrb(r29, r9);                                 //	ldxrb	w29, [x9]
    __ ldaxrb(r13, r21);                               //	ldaxrb	w13, [x21]
    __ stlrb(r12, r8);                                 //	stlrb	w12, [x8]
    __ ldarb(r22, r26);                                //	ldarb	w22, [x26]

// LoadStoreExclusiveOp
    __ ldxp(r27, r19, r10);                            //	ldxp	x27, x19, [x10]
    __ ldaxp(r29, r19, r1);                            //	ldaxp	x29, x19, [x1]
    __ stxp(r2, r22, r1, r0);                          //	stxp	w2, x22, x1, [x0]
    __ stlxp(r11, r15, r13, r14);                      //	stlxp	w11, x15, x13, [x14]

// LoadStoreExclusiveOp
    __ ldxpw(r16, r20, r12);                           //	ldxp	w16, w20, [x12]
    __ ldaxpw(r10, r29, r7);                           //	ldaxp	w10, w29, [x7]
    __ stxpw(r23, r12, r10, r1);                       //	stxp	w23, w12, w10, [x1]
    __ stlxpw(r26, r21, r27, r13);                     //	stlxp	w26, w21, w27, [x13]

// base_plus_unscaled_offset 
// LoadStoreOp
    __ str(r10, Address(r20, -103));                   //	str	x10, [x20, -103]
    __ strw(r27, Address(r15, 62));                    //	str	w27, [x15, 62]
    __ strb(r27, Address(r9, -9));                     //	strb	w27, [x9, -9]
    __ strh(r1, Address(r24, -50));                    //	strh	w1, [x24, -50]
    __ ldr(r4, Address(r2, -241));                     //	ldr	x4, [x2, -241]
    __ ldrw(r29, Address(r20, -31));                   //	ldr	w29, [x20, -31]
    __ ldrb(r17, Address(r22, -23));                   //	ldrb	w17, [x22, -23]
    __ ldrh(r28, Address(r25, -1));                    //	ldrh	w28, [x25, -1]
    __ ldrsb(r1, Address(r8, 6));                      //	ldrsb	x1, [x8, 6]
    __ ldrsh(r11, Address(r12, 19));                   //	ldrsh	x11, [x12, 19]
    __ ldrshw(r11, Address(r1, -50));                  //	ldrsh	w11, [x1, -50]
    __ ldrsw(r19, Address(r23, 41));                   //	ldrsw	x19, [x23, 41]
    __ ldrd(v23, Address(r23, 95));                    //	ldr	d23, [x23, 95]
    __ ldrs(v14, Address(r5, -43));                    //	ldr	s14, [x5, -43]
    __ strd(v21, Address(r27, 1));                     //	str	d21, [x27, 1]
    __ strs(v23, Address(r12, -107));                  //	str	s23, [x12, -107]

// pre 
// LoadStoreOp
    __ str(r11, Address(__ pre(r0, 8)));               //	str	x11, [x0, 8]!
    __ strw(r3, Address(__ pre(r0, 29)));              //	str	w3, [x0, 29]!
    __ strb(r11, Address(__ pre(r14, 9)));             //	strb	w11, [x14, 9]!
    __ strh(r29, Address(__ pre(r24, -3)));            //	strh	w29, [x24, -3]!
    __ ldr(r13, Address(__ pre(r17, -144)));           //	ldr	x13, [x17, -144]!
    __ ldrw(r12, Address(__ pre(r22, -6)));            //	ldr	w12, [x22, -6]!
    __ ldrb(r13, Address(__ pre(r12, -10)));           //	ldrb	w13, [x12, -10]!
    __ ldrh(r0, Address(__ pre(r21, -21)));            //	ldrh	w0, [x21, -21]!
    __ ldrsb(r23, Address(__ pre(r7, 4)));             //	ldrsb	x23, [x7, 4]!
    __ ldrsh(r3, Address(__ pre(r7, -53)));            //	ldrsh	x3, [x7, -53]!
    __ ldrshw(r28, Address(__ pre(r5, -7)));           //	ldrsh	w28, [x5, -7]!
    __ ldrsw(r24, Address(__ pre(r9, -18)));           //	ldrsw	x24, [x9, -18]!
    __ ldrd(v13, Address(__ pre(r10, 12)));            //	ldr	d13, [x10, 12]!
    __ ldrs(v19, Address(__ pre(r12, -67)));           //	ldr	s19, [x12, -67]!
    __ strd(v20, Address(__ pre(r0, -253)));           //	str	d20, [x0, -253]!
    __ strs(v8, Address(__ pre(r0, 64)));              //	str	s8, [x0, 64]!

// post 
// LoadStoreOp
    __ str(r4, Address(__ post(r28, -94)));            //	str	x4, [x28], -94
    __ strw(r12, Address(__ post(r7, -54)));           //	str	w12, [x7], -54
    __ strb(r27, Address(__ post(r10, -24)));          //	strb	w27, [x10], -24
    __ strh(r6, Address(__ post(r8, 27)));             //	strh	w6, [x8], 27
    __ ldr(r14, Address(__ post(r10, -202)));          //	ldr	x14, [x10], -202
    __ ldrw(r16, Address(__ post(r5, -41)));           //	ldr	w16, [x5], -41
    __ ldrb(r2, Address(__ post(r14, 9)));             //	ldrb	w2, [x14], 9
    __ ldrh(r28, Address(__ post(r13, -20)));          //	ldrh	w28, [x13], -20
    __ ldrsb(r9, Address(__ post(r13, -31)));          //	ldrsb	x9, [x13], -31
    __ ldrsh(r3, Address(__ post(r24, -36)));          //	ldrsh	x3, [x24], -36
    __ ldrshw(r20, Address(__ post(r3, 6)));           //	ldrsh	w20, [x3], 6
    __ ldrsw(r7, Address(__ post(r19, -1)));           //	ldrsw	x7, [x19], -1
    __ ldrd(v29, Address(__ post(r8, -130)));          //	ldr	d29, [x8], -130
    __ ldrs(v24, Address(__ post(r14, 21)));           //	ldr	s24, [x14], 21
    __ strd(v13, Address(__ post(r23, 90)));           //	str	d13, [x23], 90
    __ strs(v7, Address(__ post(r0, -33)));            //	str	s7, [x0], -33

// base_plus_reg 
// LoadStoreOp
    __ str(r9, Address(r17, r21, Address::sxtw(3)));   //	str	x9, [x17, w21, sxtw #3]
    __ strw(r4, Address(r12, r22, Address::sxtw(2)));  //	str	w4, [x12, w22, sxtw #2]
    __ strb(r12, Address(r0, r19, Address::uxtw(0)));  //	strb	w12, [x0, w19, uxtw #0]
    __ strh(r11, Address(r26, r6, Address::sxtw(0)));  //	strh	w11, [x26, w6, sxtw #0]
    __ ldr(r0, Address(r7, r15, Address::lsl(0)));     //	ldr	x0, [x7, x15, lsl #0]
    __ ldrw(r0, Address(r4, r26, Address::sxtx(0)));   //	ldr	w0, [x4, x26, sxtx #0]
    __ ldrb(r13, Address(r24, r4, Address::sxtw(0)));  //	ldrb	w13, [x24, w4, sxtw #0]
    __ ldrh(r8, Address(r4, r17, Address::uxtw(0)));   //	ldrh	w8, [x4, w17, uxtw #0]
    __ ldrsb(r27, Address(r4, r6, Address::lsl(0)));   //	ldrsb	x27, [x4, x6, lsl #0]
    __ ldrsh(r14, Address(r15, r29, Address::sxtw(0))); //	ldrsh	x14, [x15, w29, sxtw #0]
    __ ldrshw(r15, Address(r0, r22, Address::sxtw(0))); //	ldrsh	w15, [x0, w22, sxtw #0]
    __ ldrsw(r21, Address(r9, r29, Address::sxtx(2))); //	ldrsw	x21, [x9, x29, sxtx #2]
    __ ldrd(v28, Address(r20, r10, Address::sxtx(3))); //	ldr	d28, [x20, x10, sxtx #3]
    __ ldrs(v3, Address(r10, r19, Address::uxtw(0)));  //	ldr	s3, [x10, w19, uxtw #0]
    __ strd(v12, Address(r27, r28, Address::uxtw(3))); //	str	d12, [x27, w28, uxtw #3]
    __ strs(v22, Address(r28, r5, Address::sxtx(2)));  //	str	s22, [x28, x5, sxtx #2]

// base_plus_scaled_offset 
// LoadStoreOp
    __ str(r5, Address(r7, 12600));                    //	str	x5, [x7, 12600]
    __ strw(r28, Address(r23, 7880));                  //	str	w28, [x23, 7880]
    __ strb(r19, Address(r16, 1566));                  //	strb	w19, [x16, 1566]
    __ strh(r12, Address(r19, 3984));                  //	strh	w12, [x19, 3984]
    __ ldr(r19, Address(r22, 13632));                  //	ldr	x19, [x22, 13632]
    __ ldrw(r23, Address(r28, 6264));                  //	ldr	w23, [x28, 6264]
    __ ldrb(r21, Address(r11, 2012));                  //	ldrb	w21, [x11, 2012]
    __ ldrh(r3, Address(r9, 3784));                    //	ldrh	w3, [x9, 3784]
    __ ldrsb(r7, Address(r15, 1951));                  //	ldrsb	x7, [x15, 1951]
    __ ldrsh(r23, Address(r20, 3346));                 //	ldrsh	x23, [x20, 3346]
    __ ldrshw(r2, Address(r1, 3994));                  //	ldrsh	w2, [x1, 3994]
    __ ldrsw(r4, Address(r16, 7204));                  //	ldrsw	x4, [x16, 7204]
    __ ldrd(v19, Address(r27, 14400));                 //	ldr	d19, [x27, 14400]
    __ ldrs(v24, Address(r13, 8096));                  //	ldr	s24, [x13, 8096]
    __ strd(v25, Address(r9, 15024));                  //	str	d25, [x9, 15024]
    __ strs(v9, Address(r3, 6936));                    //	str	s9, [x3, 6936]

// pcrel 
// LoadStoreOp
    __ ldr(r27, forth);                                //	ldr	x27, forth
    __ ldrw(r10, __ pc());                             //	ldr	w10, .

// LoadStoreOp
    __ prfm(Address(r3, -187));                        //	prfm	PLDL1KEEP, [x3, -187]

// LoadStoreOp
    __ prfm(__ pc());                                  //	prfm	PLDL1KEEP, .

// LoadStoreOp
    __ prfm(Address(r28, r13, Address::lsl(0)));       //	prfm	PLDL1KEEP, [x28, x13, lsl #0]

// LoadStoreOp
    __ prfm(Address(r4, 13312));                       //	prfm	PLDL1KEEP, [x4, 13312]

// AddSubCarryOp
    __ adcw(r20, r1, r6);                              //	adc	w20, w1, w6
    __ adcsw(r8, r4, r6);                              //	adcs	w8, w4, w6
    __ sbcw(r6, r26, r13);                             //	sbc	w6, w26, w13
    __ sbcsw(r26, r4, r16);                            //	sbcs	w26, w4, w16
    __ adc(r0, r27, r0);                               //	adc	x0, x27, x0
    __ adcs(r11, r24, r29);                            //	adcs	x11, x24, x29
    __ sbc(r0, r24, r14);                              //	sbc	x0, x24, x14
    __ sbcs(r1, r23, r3);                              //	sbcs	x1, x23, x3

// AddSubExtendedOp
    __ addw(r17, r23, r20, ext::uxtb, 2);              //	add	w17, w23, w20, uxtb #2
    __ addsw(r12, r27, r9, ext::uxth, 1);              //	adds	w12, w27, w9, uxth #1
    __ sub(r14, r15, r2, ext::sxth, 2);                //	sub	x14, x15, x2, sxth #2
    __ subsw(r29, r12, r12, ext::uxth, 2);             //	subs	w29, w12, w12, uxth #2
    __ add(r11, r19, r11, ext::sxtw, 3);               //	add	x11, x19, x11, sxtw #3
    __ adds(r29, r26, r10, ext::sxtb, 1);              //	adds	x29, x26, x10, sxtb #1
    __ sub(r13, r6, r1, ext::sxtw, 2);                 //	sub	x13, x6, x1, sxtw #2
    __ subs(r28, r3, r26, ext::sxth, 1);               //	subs	x28, x3, x26, sxth #1

// ConditionalCompareOp
    __ ccmnw(r0, r12, 14u, Assembler::MI);             //	ccmn	w0, w12, #14, MI
    __ ccmpw(r21, r17, 6u, Assembler::CC);             //	ccmp	w21, w17, #6, CC
    __ ccmn(r17, r29, 14u, Assembler::VS);             //	ccmn	x17, x29, #14, VS
    __ ccmp(r10, r19, 12u, Assembler::HI);             //	ccmp	x10, x19, #12, HI

// ConditionalCompareImmedOp
    __ ccmnw(r5, 18, 2, Assembler::LE);                //	ccmn	w5, #18, #2, LE
    __ ccmpw(r8, 13, 4, Assembler::HI);                //	ccmp	w8, #13, #4, HI
    __ ccmn(r20, 11, 11, Assembler::LO);               //	ccmn	x20, #11, #11, LO
    __ ccmp(r3, 13, 2, Assembler::VC);                 //	ccmp	x3, #13, #2, VC

// ConditionalSelectOp
    __ cselw(r11, r2, r21, Assembler::HI);             //	csel	w11, w2, w21, HI
    __ csincw(r23, r15, r16, Assembler::HS);           //	csinc	w23, w15, w16, HS
    __ csinvw(r6, r6, r15, Assembler::LT);             //	csinv	w6, w6, w15, LT
    __ csnegw(r10, r26, r22, Assembler::LS);           //	csneg	w10, w26, w22, LS
    __ csel(r9, r3, r28, Assembler::LT);               //	csel	x9, x3, x28, LT
    __ csinc(r11, r26, r27, Assembler::CC);            //	csinc	x11, x26, x27, CC
    __ csinv(r14, r9, r21, Assembler::GT);             //	csinv	x14, x9, x21, GT
    __ csneg(r29, r22, r8, Assembler::GT);             //	csneg	x29, x22, x8, GT

// TwoRegOp
    __ rbitw(r29, r10);                                //	rbit	w29, w10
    __ rev16w(r28, r14);                               //	rev16	w28, w14
    __ revw(r28, r29);                                 //	rev	w28, w29
    __ clzw(r24, r20);                                 //	clz	w24, w20
    __ clsw(r4, r0);                                   //	cls	w4, w0
    __ rbit(r17, r21);                                 //	rbit	x17, x21
    __ rev16(r28, r14);                                //	rev16	x28, x14
    __ rev32(r21, r19);                                //	rev32	x21, x19
    __ rev(r5, r19);                                   //	rev	x5, x19
    __ clz(r29, r3);                                   //	clz	x29, x3
    __ cls(r20, r17);                                  //	cls	x20, x17

// ThreeRegOp
    __ udivw(r10, r24, r0);                            //	udiv	w10, w24, w0
    __ sdivw(r26, r24, r13);                           //	sdiv	w26, w24, w13
    __ lslvw(r3, r13, r16);                            //	lslv	w3, w13, w16
    __ lsrvw(r7, r14, r23);                            //	lsrv	w7, w14, w23
    __ asrvw(r27, r16, r24);                           //	asrv	w27, w16, w24
    __ rorvw(r2, r25, r27);                            //	rorv	w2, w25, w27
    __ udiv(r4, r24, r25);                             //	udiv	x4, x24, x25
    __ sdiv(r26, r14, r17);                            //	sdiv	x26, x14, x17
    __ lslv(r6, r21, r11);                             //	lslv	x6, x21, x11
    __ lsrv(r0, r3, r11);                              //	lsrv	x0, x3, x11
    __ asrv(r26, r16, r27);                            //	asrv	x26, x16, x27
    __ rorv(r27, r2, r17);                             //	rorv	x27, x2, x17
    __ umulh(r9, r14, r13);                            //	umulh	x9, x14, x13
    __ smulh(r13, r2, r25);                            //	smulh	x13, x2, x25

// FourRegMulOp
    __ maddw(r14, r19, r13, r5);                       //	madd	w14, w19, w13, w5
    __ msubw(r15, r4, r25, r25);                       //	msub	w15, w4, w25, w25
    __ madd(r4, r1, r1, r11);                          //	madd	x4, x1, x1, x11
    __ msub(r28, r16, r7, r6);                         //	msub	x28, x16, x7, x6
    __ smaddl(r3, r4, r24, r4);                        //	smaddl	x3, w4, w24, x4
    __ smsubl(r26, r24, r3, r16);                      //	smsubl	x26, w24, w3, x16
    __ umaddl(r0, r25, r16, r22);                      //	umaddl	x0, w25, w16, x22
    __ umsubl(r14, r21, r28, r16);                     //	umsubl	x14, w21, w28, x16

// ThreeRegFloatOp
    __ fmuls(v26, v9, v2);                             //	fmul	s26, s9, s2
    __ fdivs(v0, v6, v25);                             //	fdiv	s0, s6, s25
    __ fadds(v9, v6, v14);                             //	fadd	s9, s6, s14
    __ fsubs(v28, v14, v9);                            //	fsub	s28, s14, s9
    __ fmuls(v2, v16, v6);                             //	fmul	s2, s16, s6
    __ fmuld(v10, v11, v22);                           //	fmul	d10, d11, d22
    __ fdivd(v6, v28, v22);                            //	fdiv	d6, d28, d22
    __ faddd(v13, v26, v10);                           //	fadd	d13, d26, d10
    __ fsubd(v11, v3, v23);                            //	fsub	d11, d3, d23
    __ fmuld(v11, v14, v13);                           //	fmul	d11, d14, d13

// FourRegFloatOp
    __ fmadds(v20, v10, v27, v12);                     //	fmadd	s20, s10, s27, s12
    __ fmsubs(v10, v11, v23, v29);                     //	fmsub	s10, s11, s23, s29
    __ fnmadds(v26, v13, v8, v12);                     //	fnmadd	s26, s13, s8, s12
    __ fnmadds(v9, v7, v5, v28);                       //	fnmadd	s9, s7, s5, s28
    __ fmaddd(v14, v3, v11, v11);                      //	fmadd	d14, d3, d11, d11
    __ fmsubd(v14, v29, v29, v16);                     //	fmsub	d14, d29, d29, d16
    __ fnmaddd(v17, v20, v14, v14);                    //	fnmadd	d17, d20, d14, d14
    __ fnmaddd(v9, v20, v2, v9);                       //	fnmadd	d9, d20, d2, d9

// TwoRegFloatOp
    __ fmovs(v26, v6);                                 //	fmov	s26, s6
    __ fabss(v29, v29);                                //	fabs	s29, s29
    __ fnegs(v16, v1);                                 //	fneg	s16, s1
    __ fsqrts(v2, v5);                                 //	fsqrt	s2, s5
    __ fcvts(v9, v3);                                  //	fcvt	d9, s3
    __ fmovd(v24, v10);                                //	fmov	d24, d10
    __ fabsd(v6, v1);                                  //	fabs	d6, d1
    __ fnegd(v11, v0);                                 //	fneg	d11, d0
    __ fsqrtd(v3, v17);                                //	fsqrt	d3, d17
    __ fcvtd(v28, v5);                                 //	fcvt	s28, d5

// FloatConvertOp
    __ fcvtzsw(r22, v5);                               //	fcvtzs	w22, s5
    __ fcvtzs(r0, v26);                                //	fcvtzs	x0, s26
    __ fcvtzdw(r25, v1);                               //	fcvtzs	w25, d1
    __ fcvtzd(r5, v6);                                 //	fcvtzs	x5, d6
    __ scvtfws(v27, r11);                              //	scvtf	s27, w11
    __ scvtfs(v24, r12);                               //	scvtf	s24, x12
    __ scvtfwd(v11, r23);                              //	scvtf	d11, w23
    __ scvtfd(v17, r7);                                //	scvtf	d17, x7
    __ fmovs(r16, v21);                                //	fmov	w16, s21
    __ fmovd(r24, v20);                                //	fmov	x24, d20
    __ fmovs(v19, r17);                                //	fmov	s19, w17
    __ fmovd(v2, r28);                                 //	fmov	d2, x28

// TwoRegFloatOp
    __ fcmps(v21, v7);                                 //	fcmp	s21, s7
    __ fcmpd(v21, v19);                                //	fcmp	d21, d19
    __ fcmps(v20, 0.0);                                //	fcmp	s20, #0.0
    __ fcmpd(v10, 0.0);                                //	fcmp	d10, #0.0

// LoadStorePairOp
    __ stpw(r20, r5, Address(r14, -32));               //	stp	w20, w5, [x14, #-32]
    __ ldpw(r27, r14, Address(r3, -208));              //	ldp	w27, w14, [x3, #-208]
    __ ldpsw(r17, r10, Address(r10, -80));             //	ldpsw	x17, x10, [x10, #-80]
    __ stp(r6, r7, Address(r13, 64));                  //	stp	x6, x7, [x13, #64]
    __ ldp(r12, r23, Address(r0, 112));                //	ldp	x12, x23, [x0, #112]

// LoadStorePairOp
    __ stpw(r12, r7, Address(__ pre(r6, -80)));        //	stp	w12, w7, [x6, #-80]!
    __ ldpw(r30, r16, Address(__ pre(r2, -144)));      //	ldp	w30, w16, [x2, #-144]!
    __ ldpsw(r4, r1, Address(__ pre(r26, -144)));      //	ldpsw	x4, x1, [x26, #-144]!
    __ stp(r23, r13, Address(__ pre(r11, 64)));        //	stp	x23, x13, [x11, #64]!
    __ ldp(r29, r27, Address(__ pre(r21, -192)));      //	ldp	x29, x27, [x21, #-192]!

// LoadStorePairOp
    __ stpw(r21, r5, Address(__ post(r22, -48)));      //	stp	w21, w5, [x22], #-48
    __ ldpw(r27, r17, Address(__ post(r6, -32)));      //	ldp	w27, w17, [x6], #-32
    __ ldpsw(r17, r6, Address(__ post(r1, -80)));      //	ldpsw	x17, x6, [x1], #-80
    __ stp(r12, r20, Address(__ post(r21, -208)));     //	stp	x12, x20, [x21], #-208
    __ ldp(r30, r27, Address(__ post(r10, 80)));       //	ldp	x30, x27, [x10], #80

// LoadStorePairOp
    __ stnpw(r4, r16, Address(r10, 16));               //	stnp	w4, w16, [x10, #16]
    __ ldnpw(r14, r4, Address(r25, -96));              //	ldnp	w14, w4, [x25, #-96]
    __ stnp(r22, r28, Address(r11, 32));               //	stnp	x22, x28, [x11, #32]
    __ ldnp(r0, r6, Address(r21, -80));                //	ldnp	x0, x6, [x21, #-80]

// LdStSIMDOp
    __ ld1(v14, __ T8B, Address(r25));                 //	ld1	{v14.8B}, [x25]
    __ ld1(v22, v23, __ T16B, Address(__ post(r11, 32))); //	ld1	{v22.16B, v23.16B}, [x11], 32
    __ ld1(v8, v9, v10, __ T1D, Address(__ post(r23, r6))); //	ld1	{v8.1D, v9.1D, v10.1D}, [x23], x6
    __ ld1(v19, v20, v21, v22, __ T8H, Address(__ post(r25, 64))); //	ld1	{v19.8H, v20.8H, v21.8H, v22.8H}, [x25], 64
    __ ld1r(v28, __ T8B, Address(r16));                //	ld1r	{v28.8B}, [x16]
    __ ld1r(v24, __ T4S, Address(__ post(r23, 4)));    //	ld1r	{v24.4S}, [x23], 4
    __ ld1r(v9, __ T1D, Address(__ post(r5, r24)));    //	ld1r	{v9.1D}, [x5], x24
    __ ld2(v16, v17, __ T2D, Address(r9));             //	ld2	{v16.2D, v17.2D}, [x9]
    __ ld2(v11, v12, __ T4H, Address(__ post(r14, 16))); //	ld2	{v11.4H, v12.4H}, [x14], 16
    __ ld2r(v25, v26, __ T16B, Address(r17));          //	ld2r	{v25.16B, v26.16B}, [x17]
    __ ld2r(v1, v2, __ T2S, Address(__ post(r29, 8))); //	ld2r	{v1.2S, v2.2S}, [x29], 8
    __ ld2r(v15, v16, __ T2D, Address(__ post(r17, r8))); //	ld2r	{v15.2D, v16.2D}, [x17], x8
    __ ld3(v25, v26, v27, __ T4S, Address(__ post(r11, r2))); //	ld3	{v25.4S, v26.4S, v27.4S}, [x11], x2
    __ ld3(v25, v26, v27, __ T2S, Address(r19));       //	ld3	{v25.2S, v26.2S, v27.2S}, [x19]
    __ ld3r(v14, v15, v16, __ T8H, Address(r21));      //	ld3r	{v14.8H, v15.8H, v16.8H}, [x21]
    __ ld3r(v24, v25, v26, __ T4S, Address(__ post(r13, 12))); //	ld3r	{v24.4S, v25.4S, v26.4S}, [x13], 12
    __ ld3r(v13, v14, v15, __ T1D, Address(__ post(r27, r28))); //	ld3r	{v13.1D, v14.1D, v15.1D}, [x27], x28
    __ ld4(v15, v16, v17, v18, __ T8H, Address(__ post(r28, 64))); //	ld4	{v15.8H, v16.8H, v17.8H, v18.8H}, [x28], 64
    __ ld4(v26, v27, v28, v29, __ T8B, Address(__ post(r7, r0))); //	ld4	{v26.8B, v27.8B, v28.8B, v29.8B}, [x7], x0
    __ ld4r(v23, v24, v25, v26, __ T8B, Address(r16)); //	ld4r	{v23.8B, v24.8B, v25.8B, v26.8B}, [x16]
    __ ld4r(v0, v1, v2, v3, __ T4H, Address(__ post(r25, 8))); //	ld4r	{v0.4H, v1.4H, v2.4H, v3.4H}, [x25], 8
    __ ld4r(v11, v12, v13, v14, __ T2S, Address(__ post(r24, r2))); //	ld4r	{v11.2S, v12.2S, v13.2S, v14.2S}, [x24], x2

// SHA512SIMDOp
    __ sha512h(v22, __ T2D, v26, v4);                  //	sha512h		q22, q26, v4.2D
    __ sha512h2(v7, __ T2D, v6, v1);                   //	sha512h2		q7, q6, v1.2D
    __ sha512su0(v25, __ T2D, v14);                    //	sha512su0		v25.2D, v14.2D
    __ sha512su1(v1, __ T2D, v12, v13);                //	sha512su1		v1.2D, v12.2D, v13.2D

// SpecialCases
    __ ccmn(zr, zr, 3u, Assembler::LE);                //	ccmn	xzr, xzr, #3, LE
    __ ccmnw(zr, zr, 5u, Assembler::EQ);               //	ccmn	wzr, wzr, #5, EQ
    __ ccmp(zr, 1, 4u, Assembler::NE);                 //	ccmp	xzr, 1, #4, NE
    __ ccmpw(zr, 2, 2, Assembler::GT);                 //	ccmp	wzr, 2, #2, GT
    __ extr(zr, zr, zr, 0);                            //	extr	xzr, xzr, xzr, 0
    __ stlxp(r0, zr, zr, sp);                          //	stlxp	w0, xzr, xzr, [sp]
    __ stlxpw(r2, zr, zr, r3);                         //	stlxp	w2, wzr, wzr, [x3]
    __ stxp(r4, zr, zr, r5);                           //	stxp	w4, xzr, xzr, [x5]
    __ stxpw(r6, zr, zr, sp);                          //	stxp	w6, wzr, wzr, [sp]
    __ dup(v0, __ T16B, zr);                           //	dup	v0.16b, wzr
    __ mov(v1, __ T1D, 0, zr);                         //	mov	v1.d[0], xzr
    __ mov(v1, __ T2S, 1, zr);                         //	mov	v1.s[1], wzr
    __ mov(v1, __ T4H, 2, zr);                         //	mov	v1.h[2], wzr
    __ mov(v1, __ T8B, 3, zr);                         //	mov	v1.b[3], wzr
    __ ld1(v31, v0, __ T2D, Address(__ post(r1, r0))); //	ld1	{v31.2d, v0.2d}, [x1], x0
    __ sve_cpy(z0, __ S, p0, v1);                      //	mov	z0.s, p0/m, s1
    __ sve_inc(r0, __ S);                              //	incw	x0
    __ sve_dec(r1, __ H);                              //	dech	x1
    __ sve_lsl(z0, __ B, z1, 7);                       //	lsl	z0.b, z1.b, #7
    __ sve_lsl(z21, __ H, z1, 15);                     //	lsl	z21.h, z1.h, #15
    __ sve_lsl(z0, __ S, z1, 31);                      //	lsl	z0.s, z1.s, #31
    __ sve_lsl(z0, __ D, z1, 63);                      //	lsl	z0.d, z1.d, #63
    __ sve_lsr(z0, __ B, z1, 7);                       //	lsr	z0.b, z1.b, #7
    __ sve_asr(z0, __ H, z11, 15);                     //	asr	z0.h, z11.h, #15
    __ sve_lsr(z30, __ S, z1, 31);                     //	lsr	z30.s, z1.s, #31
    __ sve_asr(z0, __ D, z1, 63);                      //	asr	z0.d, z1.d, #63
    __ sve_addvl(sp, r0, 31);                          //	addvl	sp, x0, #31
    __ sve_addpl(r1, sp, -32);                         //	addpl	x1, sp, -32
    __ sve_cntp(r8, __ B, p0, p1);                     //	cntp	x8, p0, p1.b
    __ sve_dup(z0, __ B, 127);                         //	dup	z0.b, 127
    __ sve_dup(z1, __ H, -128);                        //	dup	z1.h, -128
    __ sve_dup(z2, __ S, 32512);                       //	dup	z2.s, 32512
    __ sve_dup(z7, __ D, -32768);                      //	dup	z7.d, -32768
    __ sve_ld1b(z0, __ B, p0, Address(sp));            //	ld1b	{z0.b}, p0/z, [sp]
    __ sve_ld1h(z10, __ H, p1, Address(sp, -8));       //	ld1h	{z10.h}, p1/z, [sp, #-8, MUL VL]
    __ sve_ld1w(z20, __ S, p2, Address(r0, 7));        //	ld1w	{z20.s}, p2/z, [x0, #7, MUL VL]
    __ sve_ld1b(z30, __ B, p3, Address(sp, r8));       //	ld1b	{z30.b}, p3/z, [sp, x8]
    __ sve_ld1w(z0, __ S, p4, Address(sp, r28));       //	ld1w	{z0.s}, p4/z, [sp, x28, LSL #2]
    __ sve_ld1d(z11, __ D, p5, Address(r0, r1));       //	ld1d	{z11.d}, p5/z, [x0, x1, LSL #3]
    __ sve_st1b(z22, __ B, p6, Address(sp));           //	st1b	{z22.b}, p6, [sp]
    __ sve_st1b(z31, __ B, p7, Address(sp, -8));       //	st1b	{z31.b}, p7, [sp, #-8, MUL VL]
    __ sve_st1w(z0, __ S, p1, Address(r0, 7));         //	st1w	{z0.s}, p1, [x0, #7, MUL VL]
    __ sve_st1b(z0, __ B, p2, Address(sp, r1));        //	st1b	{z0.b}, p2, [sp, x1]
    __ sve_st1h(z0, __ H, p3, Address(sp, r8));        //	st1h	{z0.h}, p3, [sp, x8, LSL #1]
    __ sve_st1d(z0, __ D, p4, Address(r0, r17));       //	st1d	{z0.d}, p4, [x0, x17, LSL #3]
    __ sve_ldr(z0, Address(sp));                       //	ldr	z0, [sp]
    __ sve_ldr(z31, Address(sp, -256));                //	ldr	z31, [sp, #-256, MUL VL]
    __ sve_str(z8, Address(r8, 255));                  //	str	z8, [x8, #255, MUL VL]

// FloatImmediateOp
    __ fmovd(v0, 2.0);                                 //	fmov d0, #2.0
    __ fmovd(v0, 2.125);                               //	fmov d0, #2.125
    __ fmovd(v0, 4.0);                                 //	fmov d0, #4.0
    __ fmovd(v0, 4.25);                                //	fmov d0, #4.25
    __ fmovd(v0, 8.0);                                 //	fmov d0, #8.0
    __ fmovd(v0, 8.5);                                 //	fmov d0, #8.5
    __ fmovd(v0, 16.0);                                //	fmov d0, #16.0
    __ fmovd(v0, 17.0);                                //	fmov d0, #17.0
    __ fmovd(v0, 0.125);                               //	fmov d0, #0.125
    __ fmovd(v0, 0.1328125);                           //	fmov d0, #0.1328125
    __ fmovd(v0, 0.25);                                //	fmov d0, #0.25
    __ fmovd(v0, 0.265625);                            //	fmov d0, #0.265625
    __ fmovd(v0, 0.5);                                 //	fmov d0, #0.5
    __ fmovd(v0, 0.53125);                             //	fmov d0, #0.53125
    __ fmovd(v0, 1.0);                                 //	fmov d0, #1.0
    __ fmovd(v0, 1.0625);                              //	fmov d0, #1.0625
    __ fmovd(v0, -2.0);                                //	fmov d0, #-2.0
    __ fmovd(v0, -2.125);                              //	fmov d0, #-2.125
    __ fmovd(v0, -4.0);                                //	fmov d0, #-4.0
    __ fmovd(v0, -4.25);                               //	fmov d0, #-4.25
    __ fmovd(v0, -8.0);                                //	fmov d0, #-8.0
    __ fmovd(v0, -8.5);                                //	fmov d0, #-8.5
    __ fmovd(v0, -16.0);                               //	fmov d0, #-16.0
    __ fmovd(v0, -17.0);                               //	fmov d0, #-17.0
    __ fmovd(v0, -0.125);                              //	fmov d0, #-0.125
    __ fmovd(v0, -0.1328125);                          //	fmov d0, #-0.1328125
    __ fmovd(v0, -0.25);                               //	fmov d0, #-0.25
    __ fmovd(v0, -0.265625);                           //	fmov d0, #-0.265625
    __ fmovd(v0, -0.5);                                //	fmov d0, #-0.5
    __ fmovd(v0, -0.53125);                            //	fmov d0, #-0.53125
    __ fmovd(v0, -1.0);                                //	fmov d0, #-1.0
    __ fmovd(v0, -1.0625);                             //	fmov d0, #-1.0625

// LSEOp
    __ swp(Assembler::xword, r24, r23, r4);            //	swp	x24, x23, [x4]
    __ ldadd(Assembler::xword, r19, r15, r0);          //	ldadd	x19, x15, [x0]
    __ ldbic(Assembler::xword, r4, r21, r11);          //	ldclr	x4, x21, [x11]
    __ ldeor(Assembler::xword, r29, r15, r21);         //	ldeor	x29, x15, [x21]
    __ ldorr(Assembler::xword, r4, r14, r23);          //	ldset	x4, x14, [x23]
    __ ldsmin(Assembler::xword, r26, r5, r11);         //	ldsmin	x26, x5, [x11]
    __ ldsmax(Assembler::xword, r14, r13, r14);        //	ldsmax	x14, x13, [x14]
    __ ldumin(Assembler::xword, r8, r25, r28);         //	ldumin	x8, x25, [x28]
    __ ldumax(Assembler::xword, r10, r20, r11);        //	ldumax	x10, x20, [x11]

// LSEOp
    __ swpa(Assembler::xword, r17, r21, r15);          //	swpa	x17, x21, [x15]
    __ ldadda(Assembler::xword, r21, r23, r26);        //	ldadda	x21, x23, [x26]
    __ ldbica(Assembler::xword, r5, r6, r15);          //	ldclra	x5, x6, [x15]
    __ ldeora(Assembler::xword, r15, r25, r15);        //	ldeora	x15, x25, [x15]
    __ ldorra(Assembler::xword, r28, r24, r15);        //	ldseta	x28, x24, [x15]
    __ ldsmina(Assembler::xword, r25, r14, r10);       //	ldsmina	x25, x14, [x10]
    __ ldsmaxa(Assembler::xword, r13, r13, r20);       //	ldsmaxa	x13, x13, [x20]
    __ ldumina(Assembler::xword, r1, r22, sp);         //	ldumina	x1, x22, [sp]
    __ ldumaxa(Assembler::xword, r13, r2, r6);         //	ldumaxa	x13, x2, [x6]

// LSEOp
    __ swpal(Assembler::xword, r3, r7, r24);           //	swpal	x3, x7, [x24]
    __ ldaddal(Assembler::xword, r0, r27, r29);        //	ldaddal	x0, x27, [x29]
    __ ldbical(Assembler::xword, r5, r5, r29);         //	ldclral	x5, x5, [x29]
    __ ldeoral(Assembler::xword, r10, r25, r0);        //	ldeoral	x10, x25, [x0]
    __ ldorral(Assembler::xword, zr, r0, r19);         //	ldsetal	xzr, x0, [x19]
    __ ldsminal(Assembler::xword, r28, r25, r9);       //	ldsminal	x28, x25, [x9]
    __ ldsmaxal(Assembler::xword, r25, r11, r14);      //	ldsmaxal	x25, x11, [x14]
    __ lduminal(Assembler::xword, r10, r10, r17);      //	lduminal	x10, x10, [x17]
    __ ldumaxal(Assembler::xword, r24, r21, r24);      //	ldumaxal	x24, x21, [x24]

// LSEOp
    __ swpl(Assembler::xword, r0, r15, r10);           //	swpl	x0, x15, [x10]
    __ ldaddl(Assembler::xword, r6, r28, r5);          //	ldaddl	x6, x28, [x5]
    __ ldbicl(Assembler::xword, r5, r5, r20);          //	ldclrl	x5, x5, [x20]
    __ ldeorl(Assembler::xword, r19, r15, r17);        //	ldeorl	x19, x15, [x17]
    __ ldorrl(Assembler::xword, r29, r26, r28);        //	ldsetl	x29, x26, [x28]
    __ ldsminl(Assembler::xword, r1, r27, r0);         //	ldsminl	x1, x27, [x0]
    __ ldsmaxl(Assembler::xword, r20, r28, r15);       //	ldsmaxl	x20, x28, [x15]
    __ lduminl(Assembler::xword, r12, r9, r28);        //	lduminl	x12, x9, [x28]
    __ ldumaxl(Assembler::xword, r28, r19, r22);       //	ldumaxl	x28, x19, [x22]

// LSEOp
    __ swp(Assembler::word, r10, r4, sp);              //	swp	w10, w4, [sp]
    __ ldadd(Assembler::word, r20, r8, sp);            //	ldadd	w20, w8, [sp]
    __ ldbic(Assembler::word, r19, r9, r27);           //	ldclr	w19, w9, [x27]
    __ ldeor(Assembler::word, r2, r25, r4);            //	ldeor	w2, w25, [x4]
    __ ldorr(Assembler::word, r3, r7, r22);            //	ldset	w3, w7, [x22]
    __ ldsmin(Assembler::word, r19, r12, r4);          //	ldsmin	w19, w12, [x4]
    __ ldsmax(Assembler::word, r28, r23, r21);         //	ldsmax	w28, w23, [x21]
    __ ldumin(Assembler::word, r25, r24, r3);          //	ldumin	w25, w24, [x3]
    __ ldumax(Assembler::word, r24, r26, r23);         //	ldumax	w24, w26, [x23]

// LSEOp
    __ swpa(Assembler::word, r14, r21, r3);            //	swpa	w14, w21, [x3]
    __ ldadda(Assembler::word, r23, r7, r24);          //	ldadda	w23, w7, [x24]
    __ ldbica(Assembler::word, r20, r15, r16);         //	ldclra	w20, w15, [x16]
    __ ldeora(Assembler::word, r2, r1, r0);            //	ldeora	w2, w1, [x0]
    __ ldorra(Assembler::word, r24, r4, r3);           //	ldseta	w24, w4, [x3]
    __ ldsmina(Assembler::word, r11, zr, r27);         //	ldsmina	w11, wzr, [x27]
    __ ldsmaxa(Assembler::word, r9, r25, r2);          //	ldsmaxa	w9, w25, [x2]
    __ ldumina(Assembler::word, r11, r17, sp);         //	ldumina	w11, w17, [sp]
    __ ldumaxa(Assembler::word, r1, r12, r28);         //	ldumaxa	w1, w12, [x28]

// LSEOp
    __ swpal(Assembler::word, r0, r17, r11);           //	swpal	w0, w17, [x11]
    __ ldaddal(Assembler::word, r16, r22, r12);        //	ldaddal	w16, w22, [x12]
    __ ldbical(Assembler::word, r27, r29, sp);         //	ldclral	w27, w29, [sp]
    __ ldeoral(Assembler::word, r1, r26, r27);         //	ldeoral	w1, w26, [x27]
    __ ldorral(Assembler::word, r4, r29, r3);          //	ldsetal	w4, w29, [x3]
    __ ldsminal(Assembler::word, r6, r29, r25);        //	ldsminal	w6, w29, [x25]
    __ ldsmaxal(Assembler::word, r17, r8, r7);         //	ldsmaxal	w17, w8, [x7]
    __ lduminal(Assembler::word, r12, r0, r20);        //	lduminal	w12, w0, [x20]
    __ ldumaxal(Assembler::word, r1, r24, r2);         //	ldumaxal	w1, w24, [x2]

// LSEOp
    __ swpl(Assembler::word, r0, r8, r24);             //	swpl	w0, w8, [x24]
    __ ldaddl(Assembler::word, r25, r15, r29);         //	ldaddl	w25, w15, [x29]
    __ ldbicl(Assembler::word, r3, r9, r23);           //	ldclrl	w3, w9, [x23]
    __ ldeorl(Assembler::word, r9, r4, r17);           //	ldeorl	w9, w4, [x17]
    __ ldorrl(Assembler::word, r1, r11, r7);           //	ldsetl	w1, w11, [x7]
    __ ldsminl(Assembler::word, r9, r14, r16);         //	ldsminl	w9, w14, [x16]
    __ ldsmaxl(Assembler::word, r2, r9, r11);          //	ldsmaxl	w2, w9, [x11]
    __ lduminl(Assembler::word, r12, r14, r12);        //	lduminl	w12, w14, [x12]
    __ ldumaxl(Assembler::word, r2, r6, r20);          //	ldumaxl	w2, w6, [x20]

// SVEVectorOp
    __ sve_add(z25, __ B, z14, z4);                    //	add	z25.b, z14.b, z4.b
    __ sve_sub(z4, __ S, z11, z16);                    //	sub	z4.s, z11.s, z16.s
    __ sve_fadd(z15, __ D, z16, z10);                  //	fadd	z15.d, z16.d, z10.d
    __ sve_fmul(z22, __ D, z11, z24);                  //	fmul	z22.d, z11.d, z24.d
    __ sve_fsub(z27, __ D, z13, z10);                  //	fsub	z27.d, z13.d, z10.d
    __ sve_abs(z1, __ H, p3, z29);                     //	abs	z1.h, p3/m, z29.h
    __ sve_add(z14, __ B, p1, z2);                     //	add	z14.b, p1/m, z14.b, z2.b
    __ sve_asr(z12, __ S, p4, z15);                    //	asr	z12.s, p4/m, z12.s, z15.s
    __ sve_cnt(z3, __ D, p0, z10);                     //	cnt	z3.d, p0/m, z10.d
    __ sve_lsl(z5, __ D, p2, z14);                     //	lsl	z5.d, p2/m, z5.d, z14.d
    __ sve_lsr(z28, __ B, p0, z19);                    //	lsr	z28.b, p0/m, z28.b, z19.b
    __ sve_mul(z19, __ S, p5, z26);                    //	mul	z19.s, p5/m, z19.s, z26.s
    __ sve_neg(z25, __ B, p6, z4);                     //	neg	z25.b, p6/m, z4.b
    __ sve_not(z22, __ B, p4, z29);                    //	not	z22.b, p4/m, z29.b
    __ sve_smax(z11, __ H, p2, z26);                   //	smax	z11.h, p2/m, z11.h, z26.h
    __ sve_smin(z27, __ S, p5, z29);                   //	smin	z27.s, p5/m, z27.s, z29.s
    __ sve_sub(z29, __ S, p1, z12);                    //	sub	z29.s, p1/m, z29.s, z12.s
    __ sve_fabs(z29, __ D, p4, z26);                   //	fabs	z29.d, p4/m, z26.d
    __ sve_fadd(z14, __ S, p3, z10);                   //	fadd	z14.s, p3/m, z14.s, z10.s
    __ sve_fdiv(z6, __ D, p7, z15);                    //	fdiv	z6.d, p7/m, z6.d, z15.d
    __ sve_fmax(z26, __ S, p7, z6);                    //	fmax	z26.s, p7/m, z26.s, z6.s
    __ sve_fmin(z19, __ D, p2, z4);                    //	fmin	z19.d, p2/m, z19.d, z4.d
    __ sve_fmul(z15, __ S, p4, z21);                   //	fmul	z15.s, p4/m, z15.s, z21.s
    __ sve_fneg(z27, __ D, p3, z21);                   //	fneg	z27.d, p3/m, z21.d
    __ sve_frintm(z17, __ S, p5, z2);                  //	frintm	z17.s, p5/m, z2.s
    __ sve_frintn(z6, __ S, p3, z14);                  //	frintn	z6.s, p3/m, z14.s
    __ sve_frintp(z11, __ D, p5, z1);                  //	frintp	z11.d, p5/m, z1.d
    __ sve_fsqrt(z17, __ S, p1, z16);                  //	fsqrt	z17.s, p1/m, z16.s
    __ sve_fsub(z14, __ S, p5, z12);                   //	fsub	z14.s, p5/m, z14.s, z12.s
    __ sve_fmla(z20, __ D, p7, z26, z11);              //	fmla	z20.d, p7/m, z26.d, z11.d
    __ sve_fmls(z3, __ D, p0, z29, z23);               //	fmls	z3.d, p0/m, z29.d, z23.d
    __ sve_fnmla(z16, __ S, p2, z27, z25);             //	fnmla	z16.s, p2/m, z27.s, z25.s
    __ sve_fnmls(z6, __ D, p5, z22, z29);              //	fnmls	z6.d, p5/m, z22.d, z29.d
    __ sve_mla(z2, __ H, p7, z25, z16);                //	mla	z2.h, p7/m, z25.h, z16.h
    __ sve_mls(z22, __ B, p4, z2, z16);                //	mls	z22.b, p4/m, z2.b, z16.b
    __ sve_and(z23, z24, z22);                         //	and	z23.d, z24.d, z22.d
    __ sve_eor(z17, z11, z3);                          //	eor	z17.d, z11.d, z3.d
    __ sve_orr(z28, z27, z15);                         //	orr	z28.d, z27.d, z15.d

// SVEReductionOp
    __ sve_andv(v5, __ S, p2, z27);                    //	andv s5, p2, z27.s
    __ sve_orv(v6, __ H, p1, z6);                      //	orv h6, p1, z6.h
    __ sve_eorv(v8, __ B, p5, z7);                     //	eorv b8, p5, z7.b
    __ sve_smaxv(v27, __ B, p5, z29);                  //	smaxv b27, p5, z29.b
    __ sve_sminv(v26, __ H, p0, z15);                  //	sminv h26, p0, z15.h
    __ sve_fminv(v3, __ D, p6, z7);                    //	fminv d3, p6, z7.d
    __ sve_fmaxv(v21, __ D, p6, z26);                  //	fmaxv d21, p6, z26.d
    __ sve_fadda(v22, __ S, p0, z4);                   //	fadda s22, p0, s22, z4.s
    __ sve_uaddv(v16, __ H, p0, z3);                   //	uaddv d16, p0, z3.h

    __ bind(forth);

/*
aarch64ops.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 <back>:
   0:	8b0c82d9 	add	x25, x22, x12, lsl #32
   4:	cb4896eb 	sub	x11, x23, x8, lsr #37
   8:	ab889ddb 	adds	x27, x14, x8, asr #39
   c:	eb9de767 	subs	x7, x27, x29, asr #57
  10:	0b9b3ec8 	add	w8, w22, w27, asr #15
  14:	4b917982 	sub	w2, w12, w17, asr #30
  18:	2b87474d 	adds	w13, w26, w7, asr #17
  1c:	6b8b56a0 	subs	w0, w21, w11, asr #21
  20:	8a1a51c0 	and	x0, x14, x26, lsl #20
  24:	aa10f4ba 	orr	x26, x5, x16, lsl #61
  28:	ca028198 	eor	x24, x12, x2, lsl #32
  2c:	ea8f8c7c 	ands	x28, x3, x15, asr #35
  30:	0a5c49f8 	and	w24, w15, w28, lsr #18
  34:	2a4b262c 	orr	w12, w17, w11, lsr #9
  38:	4a513ca5 	eor	w5, w5, w17, lsr #15
  3c:	6a9a6ac2 	ands	w2, w22, w26, asr #26
  40:	8a6fb77b 	bic	x27, x27, x15, lsr #45
  44:	aab99707 	orn	x7, x24, x25, asr #37
  48:	ca6dfe1c 	eon	x28, x16, x13, lsr #63
  4c:	ea627f1b 	bics	x27, x24, x2, lsr #31
  50:	0aa70f33 	bic	w19, w25, w7, asr #3
  54:	2aa90f06 	orn	w6, w24, w9, asr #3
  58:	4a6176a4 	eon	w4, w21, w1, lsr #29
  5c:	6a604e8f 	bics	w15, w20, w0, lsr #19
  60:	1105ed70 	add	w16, w11, #0x17b
  64:	3100583d 	adds	w29, w1, #0x16
  68:	5101f8bc 	sub	w28, w5, #0x7e
  6c:	710f0306 	subs	w6, w24, #0x3c0
  70:	9101a180 	add	x0, x12, #0x68
  74:	b10a5cc7 	adds	x7, x6, #0x297
  78:	d10810aa 	sub	x10, x5, #0x204
  7c:	f10fd041 	subs	x1, x2, #0x3f4
  80:	120cb145 	and	w5, w10, #0xfff1fff1
  84:	3217649b 	orr	w27, w4, #0xfffffe07
  88:	52174681 	eor	w1, w20, #0x7fffe00
  8c:	720c0227 	ands	w7, w17, #0x100000
  90:	9241016d 	and	x13, x11, #0x8000000000000000
  94:	b25a2949 	orr	x9, x10, #0x1ffc000000000
  98:	d278b410 	eor	x16, x0, #0x3fffffffffff00
  9c:	f26aad01 	ands	x1, x8, #0xffffffffffc00003
  a0:	14000000 	b	a0 <back+0xa0>
  a4:	17ffffd7 	b	0 <back>
  a8:	14000242 	b	9b0 <forth>
  ac:	94000000 	bl	ac <back+0xac>
  b0:	97ffffd4 	bl	0 <back>
  b4:	9400023f 	bl	9b0 <forth>
  b8:	3400000a 	cbz	w10, b8 <back+0xb8>
  bc:	34fffa2a 	cbz	w10, 0 <back>
  c0:	3400478a 	cbz	w10, 9b0 <forth>
  c4:	35000008 	cbnz	w8, c4 <back+0xc4>
  c8:	35fff9c8 	cbnz	w8, 0 <back>
  cc:	35004728 	cbnz	w8, 9b0 <forth>
  d0:	b400000a 	cbz	x10, d0 <back+0xd0>
  d4:	b4fff96a 	cbz	x10, 0 <back>
  d8:	b40046ca 	cbz	x10, 9b0 <forth>
  dc:	b500001c 	cbnz	x28, dc <back+0xdc>
  e0:	b5fff91c 	cbnz	x28, 0 <back>
  e4:	b500467c 	cbnz	x28, 9b0 <forth>
  e8:	10000013 	adr	x19, e8 <back+0xe8>
  ec:	10fff8b3 	adr	x19, 0 <back>
  f0:	10004613 	adr	x19, 9b0 <forth>
  f4:	90000013 	adrp	x19, 0 <back>
  f8:	36300015 	tbz	w21, #6, f8 <back+0xf8>
  fc:	3637f835 	tbz	w21, #6, 0 <back>
 100:	36304595 	tbz	w21, #6, 9b0 <forth>
 104:	3758000c 	tbnz	w12, #11, 104 <back+0x104>
 108:	375ff7cc 	tbnz	w12, #11, 0 <back>
 10c:	3758452c 	tbnz	w12, #11, 9b0 <forth>
 110:	128313a0 	mov	w0, #0xffffe762            	// #-6302
 114:	528a32c6 	mov	w6, #0x5196                	// #20886
 118:	7289173a 	movk	w26, #0x48b9
 11c:	92ab3acb 	mov	x11, #0xffffffffa629ffff    	// #-1507196929
 120:	d2a0bf94 	mov	x20, #0x5fc0000             	// #100401152
 124:	f2c285e7 	movk	x7, #0x142f, lsl #32
 128:	9358720e 	sbfx	x14, x16, #24, #5
 12c:	330e652e 	bfxil	w14, w9, #14, #12
 130:	53067f1a 	lsr	w26, w24, #6
 134:	93577c53 	sbfx	x19, x2, #23, #9
 138:	b34a1a8b 	bfi	x11, x20, #54, #7
 13c:	d35a4015 	ubfiz	x21, x0, #38, #17
 140:	13936c62 	extr	w2, w3, w19, #27
 144:	93c2dba8 	extr	x8, x29, x2, #54
 148:	54000000 	b.eq	148 <back+0x148>
 14c:	54fff5a0 	b.eq	0 <back>
 150:	54004300 	b.eq	9b0 <forth>
 154:	54000001 	b.ne	154 <back+0x154>
 158:	54fff541 	b.ne	0 <back>
 15c:	540042a1 	b.ne	9b0 <forth>
 160:	54000002 	b.cs	160 <back+0x160>
 164:	54fff4e2 	b.cs	0 <back>
 168:	54004242 	b.cs	9b0 <forth>
 16c:	54000002 	b.cs	16c <back+0x16c>
 170:	54fff482 	b.cs	0 <back>
 174:	540041e2 	b.cs	9b0 <forth>
 178:	54000003 	b.cc	178 <back+0x178>
 17c:	54fff423 	b.cc	0 <back>
 180:	54004183 	b.cc	9b0 <forth>
 184:	54000003 	b.cc	184 <back+0x184>
 188:	54fff3c3 	b.cc	0 <back>
 18c:	54004123 	b.cc	9b0 <forth>
 190:	54000004 	b.mi	190 <back+0x190>
 194:	54fff364 	b.mi	0 <back>
 198:	540040c4 	b.mi	9b0 <forth>
 19c:	54000005 	b.pl	19c <back+0x19c>
 1a0:	54fff305 	b.pl	0 <back>
 1a4:	54004065 	b.pl	9b0 <forth>
 1a8:	54000006 	b.vs	1a8 <back+0x1a8>
 1ac:	54fff2a6 	b.vs	0 <back>
 1b0:	54004006 	b.vs	9b0 <forth>
 1b4:	54000007 	b.vc	1b4 <back+0x1b4>
 1b8:	54fff247 	b.vc	0 <back>
 1bc:	54003fa7 	b.vc	9b0 <forth>
 1c0:	54000008 	b.hi	1c0 <back+0x1c0>
 1c4:	54fff1e8 	b.hi	0 <back>
 1c8:	54003f48 	b.hi	9b0 <forth>
 1cc:	54000009 	b.ls	1cc <back+0x1cc>
 1d0:	54fff189 	b.ls	0 <back>
 1d4:	54003ee9 	b.ls	9b0 <forth>
 1d8:	5400000a 	b.ge	1d8 <back+0x1d8>
 1dc:	54fff12a 	b.ge	0 <back>
 1e0:	54003e8a 	b.ge	9b0 <forth>
 1e4:	5400000b 	b.lt	1e4 <back+0x1e4>
 1e8:	54fff0cb 	b.lt	0 <back>
 1ec:	54003e2b 	b.lt	9b0 <forth>
 1f0:	5400000c 	b.gt	1f0 <back+0x1f0>
 1f4:	54fff06c 	b.gt	0 <back>
 1f8:	54003dcc 	b.gt	9b0 <forth>
 1fc:	5400000d 	b.le	1fc <back+0x1fc>
 200:	54fff00d 	b.le	0 <back>
 204:	54003d6d 	b.le	9b0 <forth>
 208:	5400000e 	b.al	208 <back+0x208>
 20c:	54ffefae 	b.al	0 <back>
 210:	54003d0e 	b.al	9b0 <forth>
 214:	5400000f 	b.nv	214 <back+0x214>
 218:	54ffef4f 	b.nv	0 <back>
 21c:	54003caf 	b.nv	9b0 <forth>
 220:	d40658e1 	svc	#0x32c7
 224:	d4014d22 	hvc	#0xa69
 228:	d4046543 	smc	#0x232a
 22c:	d4273f60 	brk	#0x39fb
 230:	d44cad80 	hlt	#0x656c
 234:	d503201f 	nop
 238:	d69f03e0 	eret
 23c:	d6bf03e0 	drps
 240:	d5033fdf 	isb
 244:	d5033e9f 	dsb	st
 248:	d50332bf 	dmb	oshst
 24c:	d61f01e0 	br	x15
 250:	d63f0260 	blr	x19
 254:	c80a7d1a 	stxr	w10, x26, [x8]
 258:	c800fe81 	stlxr	w0, x1, [x20]
 25c:	c85f7f90 	ldxr	x16, [x28]
 260:	c85fff7c 	ldaxr	x28, [x27]
 264:	c89ffec1 	stlr	x1, [x22]
 268:	c8dffe95 	ldar	x21, [x20]
 26c:	88157e7b 	stxr	w21, w27, [x19]
 270:	880afccf 	stlxr	w10, w15, [x6]
 274:	885f7c11 	ldxr	w17, [x0]
 278:	885ffd24 	ldaxr	w4, [x9]
 27c:	889ffeb7 	stlr	w23, [x21]
 280:	88dffe29 	ldar	w9, [x17]
 284:	48017fa4 	stxrh	w1, w4, [x29]
 288:	4808fdeb 	stlxrh	w8, w11, [x15]
 28c:	485f7da8 	ldxrh	w8, [x13]
 290:	485ffc26 	ldaxrh	w6, [x1]
 294:	489ffde5 	stlrh	w5, [x15]
 298:	48dffd62 	ldarh	w2, [x11]
 29c:	08097c4c 	stxrb	w9, w12, [x2]
 2a0:	081bff2d 	stlxrb	w27, w13, [x25]
 2a4:	085f7d3d 	ldxrb	w29, [x9]
 2a8:	085ffead 	ldaxrb	w13, [x21]
 2ac:	089ffd0c 	stlrb	w12, [x8]
 2b0:	08dfff56 	ldarb	w22, [x26]
 2b4:	c87f4d5b 	ldxp	x27, x19, [x10]
 2b8:	c87fcc3d 	ldaxp	x29, x19, [x1]
 2bc:	c8220416 	stxp	w2, x22, x1, [x0]
 2c0:	c82bb5cf 	stlxp	w11, x15, x13, [x14]
 2c4:	887f5190 	ldxp	w16, w20, [x12]
 2c8:	887ff4ea 	ldaxp	w10, w29, [x7]
 2cc:	8837282c 	stxp	w23, w12, w10, [x1]
 2d0:	883aedb5 	stlxp	w26, w21, w27, [x13]
 2d4:	f819928a 	stur	x10, [x20,#-103]
 2d8:	b803e1fb 	stur	w27, [x15,#62]
 2dc:	381f713b 	sturb	w27, [x9,#-9]
 2e0:	781ce301 	sturh	w1, [x24,#-50]
 2e4:	f850f044 	ldur	x4, [x2,#-241]
 2e8:	b85e129d 	ldur	w29, [x20,#-31]
 2ec:	385e92d1 	ldurb	w17, [x22,#-23]
 2f0:	785ff33c 	ldurh	w28, [x25,#-1]
 2f4:	39801901 	ldrsb	x1, [x8,#6]
 2f8:	7881318b 	ldursh	x11, [x12,#19]
 2fc:	78dce02b 	ldursh	w11, [x1,#-50]
 300:	b88292f3 	ldursw	x19, [x23,#41]
 304:	fc45f2f7 	ldur	d23, [x23,#95]
 308:	bc5d50ae 	ldur	s14, [x5,#-43]
 30c:	fc001375 	stur	d21, [x27,#1]
 310:	bc195197 	stur	s23, [x12,#-107]
 314:	f8008c0b 	str	x11, [x0,#8]!
 318:	b801dc03 	str	w3, [x0,#29]!
 31c:	38009dcb 	strb	w11, [x14,#9]!
 320:	781fdf1d 	strh	w29, [x24,#-3]!
 324:	f8570e2d 	ldr	x13, [x17,#-144]!
 328:	b85faecc 	ldr	w12, [x22,#-6]!
 32c:	385f6d8d 	ldrb	w13, [x12,#-10]!
 330:	785ebea0 	ldrh	w0, [x21,#-21]!
 334:	38804cf7 	ldrsb	x23, [x7,#4]!
 338:	789cbce3 	ldrsh	x3, [x7,#-53]!
 33c:	78df9cbc 	ldrsh	w28, [x5,#-7]!
 340:	b89eed38 	ldrsw	x24, [x9,#-18]!
 344:	fc40cd4d 	ldr	d13, [x10,#12]!
 348:	bc5bdd93 	ldr	s19, [x12,#-67]!
 34c:	fc103c14 	str	d20, [x0,#-253]!
 350:	bc040c08 	str	s8, [x0,#64]!
 354:	f81a2784 	str	x4, [x28],#-94
 358:	b81ca4ec 	str	w12, [x7],#-54
 35c:	381e855b 	strb	w27, [x10],#-24
 360:	7801b506 	strh	w6, [x8],#27
 364:	f853654e 	ldr	x14, [x10],#-202
 368:	b85d74b0 	ldr	w16, [x5],#-41
 36c:	384095c2 	ldrb	w2, [x14],#9
 370:	785ec5bc 	ldrh	w28, [x13],#-20
 374:	389e15a9 	ldrsb	x9, [x13],#-31
 378:	789dc703 	ldrsh	x3, [x24],#-36
 37c:	78c06474 	ldrsh	w20, [x3],#6
 380:	b89ff667 	ldrsw	x7, [x19],#-1
 384:	fc57e51d 	ldr	d29, [x8],#-130
 388:	bc4155d8 	ldr	s24, [x14],#21
 38c:	fc05a6ed 	str	d13, [x23],#90
 390:	bc1df407 	str	s7, [x0],#-33
 394:	f835da29 	str	x9, [x17,w21,sxtw #3]
 398:	b836d984 	str	w4, [x12,w22,sxtw #2]
 39c:	3833580c 	strb	w12, [x0,w19,uxtw #0]
 3a0:	7826cb4b 	strh	w11, [x26,w6,sxtw]
 3a4:	f86f68e0 	ldr	x0, [x7,x15]
 3a8:	b87ae880 	ldr	w0, [x4,x26,sxtx]
 3ac:	3864db0d 	ldrb	w13, [x24,w4,sxtw #0]
 3b0:	78714888 	ldrh	w8, [x4,w17,uxtw]
 3b4:	38a6789b 	ldrsb	x27, [x4,x6,lsl #0]
 3b8:	78bdc9ee 	ldrsh	x14, [x15,w29,sxtw]
 3bc:	78f6c80f 	ldrsh	w15, [x0,w22,sxtw]
 3c0:	b8bdf935 	ldrsw	x21, [x9,x29,sxtx #2]
 3c4:	fc6afa9c 	ldr	d28, [x20,x10,sxtx #3]
 3c8:	bc734943 	ldr	s3, [x10,w19,uxtw]
 3cc:	fc3c5b6c 	str	d12, [x27,w28,uxtw #3]
 3d0:	bc25fb96 	str	s22, [x28,x5,sxtx #2]
 3d4:	f9189ce5 	str	x5, [x7,#12600]
 3d8:	b91ecafc 	str	w28, [x23,#7880]
 3dc:	39187a13 	strb	w19, [x16,#1566]
 3e0:	791f226c 	strh	w12, [x19,#3984]
 3e4:	f95aa2d3 	ldr	x19, [x22,#13632]
 3e8:	b9587b97 	ldr	w23, [x28,#6264]
 3ec:	395f7175 	ldrb	w21, [x11,#2012]
 3f0:	795d9123 	ldrh	w3, [x9,#3784]
 3f4:	399e7de7 	ldrsb	x7, [x15,#1951]
 3f8:	799a2697 	ldrsh	x23, [x20,#3346]
 3fc:	79df3422 	ldrsh	w2, [x1,#3994]
 400:	b99c2604 	ldrsw	x4, [x16,#7204]
 404:	fd5c2373 	ldr	d19, [x27,#14400]
 408:	bd5fa1b8 	ldr	s24, [x13,#8096]
 40c:	fd1d5939 	str	d25, [x9,#15024]
 410:	bd1b1869 	str	s9, [x3,#6936]
 414:	58002cfb 	ldr	x27, 9b0 <forth>
 418:	1800000a 	ldr	w10, 418 <back+0x418>
 41c:	f8945060 	prfum	pldl1keep, [x3,#-187]
 420:	d8000000 	prfm	pldl1keep, 420 <back+0x420>
 424:	f8ad6b80 	prfm	pldl1keep, [x28,x13]
 428:	f99a0080 	prfm	pldl1keep, [x4,#13312]
 42c:	1a060034 	adc	w20, w1, w6
 430:	3a060088 	adcs	w8, w4, w6
 434:	5a0d0346 	sbc	w6, w26, w13
 438:	7a10009a 	sbcs	w26, w4, w16
 43c:	9a000360 	adc	x0, x27, x0
 440:	ba1d030b 	adcs	x11, x24, x29
 444:	da0e0300 	sbc	x0, x24, x14
 448:	fa0302e1 	sbcs	x1, x23, x3
 44c:	0b340af1 	add	w17, w23, w20, uxtb #2
 450:	2b29276c 	adds	w12, w27, w9, uxth #1
 454:	cb22a9ee 	sub	x14, x15, w2, sxth #2
 458:	6b2c299d 	subs	w29, w12, w12, uxth #2
 45c:	8b2bce6b 	add	x11, x19, w11, sxtw #3
 460:	ab2a875d 	adds	x29, x26, w10, sxtb #1
 464:	cb21c8cd 	sub	x13, x6, w1, sxtw #2
 468:	eb3aa47c 	subs	x28, x3, w26, sxth #1
 46c:	3a4c400e 	ccmn	w0, w12, #0xe, mi
 470:	7a5132a6 	ccmp	w21, w17, #0x6, cc
 474:	ba5d622e 	ccmn	x17, x29, #0xe, vs
 478:	fa53814c 	ccmp	x10, x19, #0xc, hi
 47c:	3a52d8a2 	ccmn	w5, #0x12, #0x2, le
 480:	7a4d8904 	ccmp	w8, #0xd, #0x4, hi
 484:	ba4b3a8b 	ccmn	x20, #0xb, #0xb, cc
 488:	fa4d7862 	ccmp	x3, #0xd, #0x2, vc
 48c:	1a95804b 	csel	w11, w2, w21, hi
 490:	1a9025f7 	csinc	w23, w15, w16, cs
 494:	5a8fb0c6 	csinv	w6, w6, w15, lt
 498:	5a96974a 	csneg	w10, w26, w22, ls
 49c:	9a9cb069 	csel	x9, x3, x28, lt
 4a0:	9a9b374b 	csinc	x11, x26, x27, cc
 4a4:	da95c12e 	csinv	x14, x9, x21, gt
 4a8:	da88c6dd 	csneg	x29, x22, x8, gt
 4ac:	5ac0015d 	rbit	w29, w10
 4b0:	5ac005dc 	rev16	w28, w14
 4b4:	5ac00bbc 	rev	w28, w29
 4b8:	5ac01298 	clz	w24, w20
 4bc:	5ac01404 	cls	w4, w0
 4c0:	dac002b1 	rbit	x17, x21
 4c4:	dac005dc 	rev16	x28, x14
 4c8:	dac00a75 	rev32	x21, x19
 4cc:	dac00e65 	rev	x5, x19
 4d0:	dac0107d 	clz	x29, x3
 4d4:	dac01634 	cls	x20, x17
 4d8:	1ac00b0a 	udiv	w10, w24, w0
 4dc:	1acd0f1a 	sdiv	w26, w24, w13
 4e0:	1ad021a3 	lsl	w3, w13, w16
 4e4:	1ad725c7 	lsr	w7, w14, w23
 4e8:	1ad82a1b 	asr	w27, w16, w24
 4ec:	1adb2f22 	ror	w2, w25, w27
 4f0:	9ad90b04 	udiv	x4, x24, x25
 4f4:	9ad10dda 	sdiv	x26, x14, x17
 4f8:	9acb22a6 	lsl	x6, x21, x11
 4fc:	9acb2460 	lsr	x0, x3, x11
 500:	9adb2a1a 	asr	x26, x16, x27
 504:	9ad12c5b 	ror	x27, x2, x17
 508:	9bcd7dc9 	umulh	x9, x14, x13
 50c:	9b597c4d 	smulh	x13, x2, x25
 510:	1b0d166e 	madd	w14, w19, w13, w5
 514:	1b19e48f 	msub	w15, w4, w25, w25
 518:	9b012c24 	madd	x4, x1, x1, x11
 51c:	9b079a1c 	msub	x28, x16, x7, x6
 520:	9b381083 	smaddl	x3, w4, w24, x4
 524:	9b23c31a 	smsubl	x26, w24, w3, x16
 528:	9bb05b20 	umaddl	x0, w25, w16, x22
 52c:	9bbcc2ae 	umsubl	x14, w21, w28, x16
 530:	1e22093a 	fmul	s26, s9, s2
 534:	1e3918c0 	fdiv	s0, s6, s25
 538:	1e2e28c9 	fadd	s9, s6, s14
 53c:	1e2939dc 	fsub	s28, s14, s9
 540:	1e260a02 	fmul	s2, s16, s6
 544:	1e76096a 	fmul	d10, d11, d22
 548:	1e761b86 	fdiv	d6, d28, d22
 54c:	1e6a2b4d 	fadd	d13, d26, d10
 550:	1e77386b 	fsub	d11, d3, d23
 554:	1e6d09cb 	fmul	d11, d14, d13
 558:	1f1b3154 	fmadd	s20, s10, s27, s12
 55c:	1f17f56a 	fmsub	s10, s11, s23, s29
 560:	1f2831ba 	fnmadd	s26, s13, s8, s12
 564:	1f2570e9 	fnmadd	s9, s7, s5, s28
 568:	1f4b2c6e 	fmadd	d14, d3, d11, d11
 56c:	1f5dc3ae 	fmsub	d14, d29, d29, d16
 570:	1f6e3a91 	fnmadd	d17, d20, d14, d14
 574:	1f622689 	fnmadd	d9, d20, d2, d9
 578:	1e2040da 	fmov	s26, s6
 57c:	1e20c3bd 	fabs	s29, s29
 580:	1e214030 	fneg	s16, s1
 584:	1e21c0a2 	fsqrt	s2, s5
 588:	1e22c069 	fcvt	d9, s3
 58c:	1e604158 	fmov	d24, d10
 590:	1e60c026 	fabs	d6, d1
 594:	1e61400b 	fneg	d11, d0
 598:	1e61c223 	fsqrt	d3, d17
 59c:	1e6240bc 	fcvt	s28, d5
 5a0:	1e3800b6 	fcvtzs	w22, s5
 5a4:	9e380340 	fcvtzs	x0, s26
 5a8:	1e780039 	fcvtzs	w25, d1
 5ac:	9e7800c5 	fcvtzs	x5, d6
 5b0:	1e22017b 	scvtf	s27, w11
 5b4:	9e220198 	scvtf	s24, x12
 5b8:	1e6202eb 	scvtf	d11, w23
 5bc:	9e6200f1 	scvtf	d17, x7
 5c0:	1e2602b0 	fmov	w16, s21
 5c4:	9e660298 	fmov	x24, d20
 5c8:	1e270233 	fmov	s19, w17
 5cc:	9e670382 	fmov	d2, x28
 5d0:	1e2722a0 	fcmp	s21, s7
 5d4:	1e7322a0 	fcmp	d21, d19
 5d8:	1e202288 	fcmp	s20, #0.0
 5dc:	1e602148 	fcmp	d10, #0.0
 5e0:	293c15d4 	stp	w20, w5, [x14,#-32]
 5e4:	2966387b 	ldp	w27, w14, [x3,#-208]
 5e8:	69762951 	ldpsw	x17, x10, [x10,#-80]
 5ec:	a9041da6 	stp	x6, x7, [x13,#64]
 5f0:	a9475c0c 	ldp	x12, x23, [x0,#112]
 5f4:	29b61ccc 	stp	w12, w7, [x6,#-80]!
 5f8:	29ee405e 	ldp	w30, w16, [x2,#-144]!
 5fc:	69ee0744 	ldpsw	x4, x1, [x26,#-144]!
 600:	a9843577 	stp	x23, x13, [x11,#64]!
 604:	a9f46ebd 	ldp	x29, x27, [x21,#-192]!
 608:	28ba16d5 	stp	w21, w5, [x22],#-48
 60c:	28fc44db 	ldp	w27, w17, [x6],#-32
 610:	68f61831 	ldpsw	x17, x6, [x1],#-80
 614:	a8b352ac 	stp	x12, x20, [x21],#-208
 618:	a8c56d5e 	ldp	x30, x27, [x10],#80
 61c:	28024144 	stnp	w4, w16, [x10,#16]
 620:	2874132e 	ldnp	w14, w4, [x25,#-96]
 624:	a8027176 	stnp	x22, x28, [x11,#32]
 628:	a87b1aa0 	ldnp	x0, x6, [x21,#-80]
 62c:	0c40732e 	ld1	{v14.8b}, [x25]
 630:	4cdfa176 	ld1	{v22.16b, v23.16b}, [x11], #32
 634:	0cc66ee8 	ld1	{v8.1d-v10.1d}, [x23], x6
 638:	4cdf2733 	ld1	{v19.8h-v22.8h}, [x25], #64
 63c:	0d40c21c 	ld1r	{v28.8b}, [x16]
 640:	4ddfcaf8 	ld1r	{v24.4s}, [x23], #4
 644:	0dd8cca9 	ld1r	{v9.1d}, [x5], x24
 648:	4c408d30 	ld2	{v16.2d, v17.2d}, [x9]
 64c:	0cdf85cb 	ld2	{v11.4h, v12.4h}, [x14], #16
 650:	4d60c239 	ld2r	{v25.16b, v26.16b}, [x17]
 654:	0dffcba1 	ld2r	{v1.2s, v2.2s}, [x29], #8
 658:	4de8ce2f 	ld2r	{v15.2d, v16.2d}, [x17], x8
 65c:	4cc24979 	ld3	{v25.4s-v27.4s}, [x11], x2
 660:	0c404a79 	ld3	{v25.2s-v27.2s}, [x19]
 664:	4d40e6ae 	ld3r	{v14.8h-v16.8h}, [x21]
 668:	4ddfe9b8 	ld3r	{v24.4s-v26.4s}, [x13], #12
 66c:	0ddcef6d 	ld3r	{v13.1d-v15.1d}, [x27], x28
 670:	4cdf078f 	ld4	{v15.8h-v18.8h}, [x28], #64
 674:	0cc000fa 	ld4	{v26.8b-v29.8b}, [x7], x0
 678:	0d60e217 	ld4r	{v23.8b-v26.8b}, [x16]
 67c:	0dffe720 	ld4r	{v0.4h-v3.4h}, [x25], #8
 680:	0de2eb0b 	ld4r	{v11.2s-v14.2s}, [x24], x2
 684:	ce648356 	.inst	0xce648356 ; undefined
 688:	ce6184c7 	.inst	0xce6184c7 ; undefined
 68c:	cec081d9 	.inst	0xcec081d9 ; undefined
 690:	ce6d8981 	.inst	0xce6d8981 ; undefined
 694:	ba5fd3e3 	ccmn	xzr, xzr, #0x3, le
 698:	3a5f03e5 	ccmn	wzr, wzr, #0x5, eq
 69c:	fa411be4 	ccmp	xzr, #0x1, #0x4, ne
 6a0:	7a42cbe2 	ccmp	wzr, #0x2, #0x2, gt
 6a4:	93df03ff 	ror	xzr, xzr, #0
 6a8:	c820ffff 	stlxp	w0, xzr, xzr, [sp]
 6ac:	8822fc7f 	stlxp	w2, wzr, wzr, [x3]
 6b0:	c8247cbf 	stxp	w4, xzr, xzr, [x5]
 6b4:	88267fff 	stxp	w6, wzr, wzr, [sp]
 6b8:	4e010fe0 	dup	v0.16b, wzr
 6bc:	4e081fe1 	mov	v1.d[0], xzr
 6c0:	4e0c1fe1 	mov	v1.s[1], wzr
 6c4:	4e0a1fe1 	mov	v1.h[2], wzr
 6c8:	4e071fe1 	mov	v1.b[3], wzr
 6cc:	4cc0ac3f 	ld1	{v31.2d, v0.2d}, [x1], x0
 6d0:	05a08020 	.inst	0x05a08020 ; undefined
 6d4:	04b0e3e0 	.inst	0x04b0e3e0 ; undefined
 6d8:	0470e7e1 	.inst	0x0470e7e1 ; undefined
 6dc:	042f9c20 	.inst	0x042f9c20 ; undefined
 6e0:	043f9c35 	.inst	0x043f9c35 ; undefined
 6e4:	047f9c20 	.inst	0x047f9c20 ; undefined
 6e8:	04ff9c20 	.inst	0x04ff9c20 ; undefined
 6ec:	04299420 	.inst	0x04299420 ; undefined
 6f0:	04319160 	.inst	0x04319160 ; undefined
 6f4:	0461943e 	.inst	0x0461943e ; undefined
 6f8:	04a19020 	.inst	0x04a19020 ; undefined
 6fc:	042053ff 	.inst	0x042053ff ; undefined
 700:	047f5401 	.inst	0x047f5401 ; undefined
 704:	25208028 	.inst	0x25208028 ; undefined
 708:	2538cfe0 	.inst	0x2538cfe0 ; undefined
 70c:	2578d001 	.inst	0x2578d001 ; undefined
 710:	25b8efe2 	.inst	0x25b8efe2 ; undefined
 714:	25f8f007 	.inst	0x25f8f007 ; undefined
 718:	a400a3e0 	.inst	0xa400a3e0 ; undefined
 71c:	a4a8a7ea 	.inst	0xa4a8a7ea ; undefined
 720:	a547a814 	.inst	0xa547a814 ; undefined
 724:	a4084ffe 	.inst	0xa4084ffe ; undefined
 728:	a55c53e0 	.inst	0xa55c53e0 ; undefined
 72c:	a5e1540b 	.inst	0xa5e1540b ; undefined
 730:	e400fbf6 	.inst	0xe400fbf6 ; undefined
 734:	e408ffff 	.inst	0xe408ffff ; undefined
 738:	e547e400 	.inst	0xe547e400 ; undefined
 73c:	e4014be0 	.inst	0xe4014be0 ; undefined
 740:	e4a84fe0 	.inst	0xe4a84fe0 ; undefined
 744:	e5f15000 	.inst	0xe5f15000 ; undefined
 748:	858043e0 	.inst	0x858043e0 ; undefined
 74c:	85a043ff 	.inst	0x85a043ff ; undefined
 750:	e59f5d08 	.inst	0xe59f5d08 ; undefined
 754:	1e601000 	fmov	d0, #2.000000000000000000e+00
 758:	1e603000 	fmov	d0, #2.125000000000000000e+00
 75c:	1e621000 	fmov	d0, #4.000000000000000000e+00
 760:	1e623000 	fmov	d0, #4.250000000000000000e+00
 764:	1e641000 	fmov	d0, #8.000000000000000000e+00
 768:	1e643000 	fmov	d0, #8.500000000000000000e+00
 76c:	1e661000 	fmov	d0, #1.600000000000000000e+01
 770:	1e663000 	fmov	d0, #1.700000000000000000e+01
 774:	1e681000 	fmov	d0, #1.250000000000000000e-01
 778:	1e683000 	fmov	d0, #1.328125000000000000e-01
 77c:	1e6a1000 	fmov	d0, #2.500000000000000000e-01
 780:	1e6a3000 	fmov	d0, #2.656250000000000000e-01
 784:	1e6c1000 	fmov	d0, #5.000000000000000000e-01
 788:	1e6c3000 	fmov	d0, #5.312500000000000000e-01
 78c:	1e6e1000 	fmov	d0, #1.000000000000000000e+00
 790:	1e6e3000 	fmov	d0, #1.062500000000000000e+00
 794:	1e701000 	fmov	d0, #-2.000000000000000000e+00
 798:	1e703000 	fmov	d0, #-2.125000000000000000e+00
 79c:	1e721000 	fmov	d0, #-4.000000000000000000e+00
 7a0:	1e723000 	fmov	d0, #-4.250000000000000000e+00
 7a4:	1e741000 	fmov	d0, #-8.000000000000000000e+00
 7a8:	1e743000 	fmov	d0, #-8.500000000000000000e+00
 7ac:	1e761000 	fmov	d0, #-1.600000000000000000e+01
 7b0:	1e763000 	fmov	d0, #-1.700000000000000000e+01
 7b4:	1e781000 	fmov	d0, #-1.250000000000000000e-01
 7b8:	1e783000 	fmov	d0, #-1.328125000000000000e-01
 7bc:	1e7a1000 	fmov	d0, #-2.500000000000000000e-01
 7c0:	1e7a3000 	fmov	d0, #-2.656250000000000000e-01
 7c4:	1e7c1000 	fmov	d0, #-5.000000000000000000e-01
 7c8:	1e7c3000 	fmov	d0, #-5.312500000000000000e-01
 7cc:	1e7e1000 	fmov	d0, #-1.000000000000000000e+00
 7d0:	1e7e3000 	fmov	d0, #-1.062500000000000000e+00
 7d4:	f8388097 	swp	x24, x23, [x4]
 7d8:	f833000f 	ldadd	x19, x15, [x0]
 7dc:	f8241175 	ldclr	x4, x21, [x11]
 7e0:	f83d22af 	ldeor	x29, x15, [x21]
 7e4:	f82432ee 	ldset	x4, x14, [x23]
 7e8:	f83a5165 	ldsmin	x26, x5, [x11]
 7ec:	f82e41cd 	ldsmax	x14, x13, [x14]
 7f0:	f8287399 	ldumin	x8, x25, [x28]
 7f4:	f82a6174 	ldumax	x10, x20, [x11]
 7f8:	f8b181f5 	swpa	x17, x21, [x15]
 7fc:	f8b50357 	ldadda	x21, x23, [x26]
 800:	f8a511e6 	ldclra	x5, x6, [x15]
 804:	f8af21f9 	ldeora	x15, x25, [x15]
 808:	f8bc31f8 	ldseta	x28, x24, [x15]
 80c:	f8b9514e 	ldsmina	x25, x14, [x10]
 810:	f8ad428d 	ldsmaxa	x13, x13, [x20]
 814:	f8a173f6 	ldumina	x1, x22, [sp]
 818:	f8ad60c2 	ldumaxa	x13, x2, [x6]
 81c:	f8e38307 	swpal	x3, x7, [x24]
 820:	f8e003bb 	ldaddal	x0, x27, [x29]
 824:	f8e513a5 	ldclral	x5, x5, [x29]
 828:	f8ea2019 	ldeoral	x10, x25, [x0]
 82c:	f8ff3260 	ldsetal	xzr, x0, [x19]
 830:	f8fc5139 	ldsminal	x28, x25, [x9]
 834:	f8f941cb 	ldsmaxal	x25, x11, [x14]
 838:	f8ea722a 	lduminal	x10, x10, [x17]
 83c:	f8f86315 	ldumaxal	x24, x21, [x24]
 840:	f860814f 	swpl	x0, x15, [x10]
 844:	f86600bc 	ldaddl	x6, x28, [x5]
 848:	f8651285 	ldclrl	x5, x5, [x20]
 84c:	f873222f 	ldeorl	x19, x15, [x17]
 850:	f87d339a 	ldsetl	x29, x26, [x28]
 854:	f861501b 	ldsminl	x1, x27, [x0]
 858:	f87441fc 	ldsmaxl	x20, x28, [x15]
 85c:	f86c7389 	lduminl	x12, x9, [x28]
 860:	f87c62d3 	ldumaxl	x28, x19, [x22]
 864:	b82a83e4 	swp	w10, w4, [sp]
 868:	b83403e8 	ldadd	w20, w8, [sp]
 86c:	b8331369 	ldclr	w19, w9, [x27]
 870:	b8222099 	ldeor	w2, w25, [x4]
 874:	b82332c7 	ldset	w3, w7, [x22]
 878:	b833508c 	ldsmin	w19, w12, [x4]
 87c:	b83c42b7 	ldsmax	w28, w23, [x21]
 880:	b8397078 	ldumin	w25, w24, [x3]
 884:	b83862fa 	ldumax	w24, w26, [x23]
 888:	b8ae8075 	swpa	w14, w21, [x3]
 88c:	b8b70307 	ldadda	w23, w7, [x24]
 890:	b8b4120f 	ldclra	w20, w15, [x16]
 894:	b8a22001 	ldeora	w2, w1, [x0]
 898:	b8b83064 	ldseta	w24, w4, [x3]
 89c:	b8ab537f 	ldsmina	w11, wzr, [x27]
 8a0:	b8a94059 	ldsmaxa	w9, w25, [x2]
 8a4:	b8ab73f1 	ldumina	w11, w17, [sp]
 8a8:	b8a1638c 	ldumaxa	w1, w12, [x28]
 8ac:	b8e08171 	swpal	w0, w17, [x11]
 8b0:	b8f00196 	ldaddal	w16, w22, [x12]
 8b4:	b8fb13fd 	ldclral	w27, w29, [sp]
 8b8:	b8e1237a 	ldeoral	w1, w26, [x27]
 8bc:	b8e4307d 	ldsetal	w4, w29, [x3]
 8c0:	b8e6533d 	ldsminal	w6, w29, [x25]
 8c4:	b8f140e8 	ldsmaxal	w17, w8, [x7]
 8c8:	b8ec7280 	lduminal	w12, w0, [x20]
 8cc:	b8e16058 	ldumaxal	w1, w24, [x2]
 8d0:	b8608308 	swpl	w0, w8, [x24]
 8d4:	b87903af 	ldaddl	w25, w15, [x29]
 8d8:	b86312e9 	ldclrl	w3, w9, [x23]
 8dc:	b8692224 	ldeorl	w9, w4, [x17]
 8e0:	b86130eb 	ldsetl	w1, w11, [x7]
 8e4:	b869520e 	ldsminl	w9, w14, [x16]
 8e8:	b8624169 	ldsmaxl	w2, w9, [x11]
 8ec:	b86c718e 	lduminl	w12, w14, [x12]
 8f0:	b8626286 	ldumaxl	w2, w6, [x20]
 8f4:	042401d9 	.inst	0x042401d9 ; undefined
 8f8:	04b00564 	.inst	0x04b00564 ; undefined
 8fc:	65ca020f 	.inst	0x65ca020f ; undefined
 900:	65d80976 	.inst	0x65d80976 ; undefined
 904:	65ca05bb 	.inst	0x65ca05bb ; undefined
 908:	0456afa1 	.inst	0x0456afa1 ; undefined
 90c:	0400044e 	.inst	0x0400044e ; undefined
 910:	049091ec 	.inst	0x049091ec ; undefined
 914:	04daa143 	.inst	0x04daa143 ; undefined
 918:	04d389c5 	.inst	0x04d389c5 ; undefined
 91c:	0411827c 	.inst	0x0411827c ; undefined
 920:	04901753 	.inst	0x04901753 ; undefined
 924:	0417b899 	.inst	0x0417b899 ; undefined
 928:	041eb3b6 	.inst	0x041eb3b6 ; undefined
 92c:	04480b4b 	.inst	0x04480b4b ; undefined
 930:	048a17bb 	.inst	0x048a17bb ; undefined
 934:	0481059d 	.inst	0x0481059d ; undefined
 938:	04dcb35d 	.inst	0x04dcb35d ; undefined
 93c:	65808d4e 	.inst	0x65808d4e ; undefined
 940:	65cd9de6 	.inst	0x65cd9de6 ; undefined
 944:	65869cda 	.inst	0x65869cda ; undefined
 948:	65c78893 	.inst	0x65c78893 ; undefined
 94c:	658292af 	.inst	0x658292af ; undefined
 950:	04ddaebb 	.inst	0x04ddaebb ; undefined
 954:	6582b451 	.inst	0x6582b451 ; undefined
 958:	6580adc6 	.inst	0x6580adc6 ; undefined
 95c:	65c1b42b 	.inst	0x65c1b42b ; undefined
 960:	658da611 	.inst	0x658da611 ; undefined
 964:	6581958e 	.inst	0x6581958e ; undefined
 968:	65eb1f54 	.inst	0x65eb1f54 ; undefined
 96c:	65f723a3 	.inst	0x65f723a3 ; undefined
 970:	65b94b70 	.inst	0x65b94b70 ; undefined
 974:	65fd76c6 	.inst	0x65fd76c6 ; undefined
 978:	04505f22 	.inst	0x04505f22 ; undefined
 97c:	04107056 	.inst	0x04107056 ; undefined
 980:	04363317 	.inst	0x04363317 ; undefined
 984:	04a33171 	.inst	0x04a33171 ; undefined
 988:	046f337c 	.inst	0x046f337c ; undefined
 98c:	049a2b65 	.inst	0x049a2b65 ; undefined
 990:	045824c6 	.inst	0x045824c6 ; undefined
 994:	041934e8 	.inst	0x041934e8 ; undefined
 998:	040837bb 	.inst	0x040837bb ; undefined
 99c:	044a21fa 	.inst	0x044a21fa ; undefined
 9a0:	65c738e3 	.inst	0x65c738e3 ; undefined
 9a4:	65c63b55 	.inst	0x65c63b55 ; undefined
 9a8:	65982096 	.inst	0x65982096 ; undefined
 9ac:	04412070 	.inst	0x04412070 ; undefined
 */

  static const unsigned int insns[] =
  {
    0x8b0c82d9,     0xcb4896eb,     0xab889ddb,     0xeb9de767,
    0x0b9b3ec8,     0x4b917982,     0x2b87474d,     0x6b8b56a0,
    0x8a1a51c0,     0xaa10f4ba,     0xca028198,     0xea8f8c7c,
    0x0a5c49f8,     0x2a4b262c,     0x4a513ca5,     0x6a9a6ac2,
    0x8a6fb77b,     0xaab99707,     0xca6dfe1c,     0xea627f1b,
    0x0aa70f33,     0x2aa90f06,     0x4a6176a4,     0x6a604e8f,
    0x1105ed70,     0x3100583d,     0x5101f8bc,     0x710f0306,
    0x9101a180,     0xb10a5cc7,     0xd10810aa,     0xf10fd041,
    0x120cb145,     0x3217649b,     0x52174681,     0x720c0227,
    0x9241016d,     0xb25a2949,     0xd278b410,     0xf26aad01,
    0x14000000,     0x17ffffd7,     0x14000242,     0x94000000,
    0x97ffffd4,     0x9400023f,     0x3400000a,     0x34fffa2a,
    0x3400478a,     0x35000008,     0x35fff9c8,     0x35004728,
    0xb400000a,     0xb4fff96a,     0xb40046ca,     0xb500001c,
    0xb5fff91c,     0xb500467c,     0x10000013,     0x10fff8b3,
    0x10004613,     0x90000013,     0x36300015,     0x3637f835,
    0x36304595,     0x3758000c,     0x375ff7cc,     0x3758452c,
    0x128313a0,     0x528a32c6,     0x7289173a,     0x92ab3acb,
    0xd2a0bf94,     0xf2c285e7,     0x9358720e,     0x330e652e,
    0x53067f1a,     0x93577c53,     0xb34a1a8b,     0xd35a4015,
    0x13936c62,     0x93c2dba8,     0x54000000,     0x54fff5a0,
    0x54004300,     0x54000001,     0x54fff541,     0x540042a1,
    0x54000002,     0x54fff4e2,     0x54004242,     0x54000002,
    0x54fff482,     0x540041e2,     0x54000003,     0x54fff423,
    0x54004183,     0x54000003,     0x54fff3c3,     0x54004123,
    0x54000004,     0x54fff364,     0x540040c4,     0x54000005,
    0x54fff305,     0x54004065,     0x54000006,     0x54fff2a6,
    0x54004006,     0x54000007,     0x54fff247,     0x54003fa7,
    0x54000008,     0x54fff1e8,     0x54003f48,     0x54000009,
    0x54fff189,     0x54003ee9,     0x5400000a,     0x54fff12a,
    0x54003e8a,     0x5400000b,     0x54fff0cb,     0x54003e2b,
    0x5400000c,     0x54fff06c,     0x54003dcc,     0x5400000d,
    0x54fff00d,     0x54003d6d,     0x5400000e,     0x54ffefae,
    0x54003d0e,     0x5400000f,     0x54ffef4f,     0x54003caf,
    0xd40658e1,     0xd4014d22,     0xd4046543,     0xd4273f60,
    0xd44cad80,     0xd503201f,     0xd69f03e0,     0xd6bf03e0,
    0xd5033fdf,     0xd5033e9f,     0xd50332bf,     0xd61f01e0,
    0xd63f0260,     0xc80a7d1a,     0xc800fe81,     0xc85f7f90,
    0xc85fff7c,     0xc89ffec1,     0xc8dffe95,     0x88157e7b,
    0x880afccf,     0x885f7c11,     0x885ffd24,     0x889ffeb7,
    0x88dffe29,     0x48017fa4,     0x4808fdeb,     0x485f7da8,
    0x485ffc26,     0x489ffde5,     0x48dffd62,     0x08097c4c,
    0x081bff2d,     0x085f7d3d,     0x085ffead,     0x089ffd0c,
    0x08dfff56,     0xc87f4d5b,     0xc87fcc3d,     0xc8220416,
    0xc82bb5cf,     0x887f5190,     0x887ff4ea,     0x8837282c,
    0x883aedb5,     0xf819928a,     0xb803e1fb,     0x381f713b,
    0x781ce301,     0xf850f044,     0xb85e129d,     0x385e92d1,
    0x785ff33c,     0x39801901,     0x7881318b,     0x78dce02b,
    0xb88292f3,     0xfc45f2f7,     0xbc5d50ae,     0xfc001375,
    0xbc195197,     0xf8008c0b,     0xb801dc03,     0x38009dcb,
    0x781fdf1d,     0xf8570e2d,     0xb85faecc,     0x385f6d8d,
    0x785ebea0,     0x38804cf7,     0x789cbce3,     0x78df9cbc,
    0xb89eed38,     0xfc40cd4d,     0xbc5bdd93,     0xfc103c14,
    0xbc040c08,     0xf81a2784,     0xb81ca4ec,     0x381e855b,
    0x7801b506,     0xf853654e,     0xb85d74b0,     0x384095c2,
    0x785ec5bc,     0x389e15a9,     0x789dc703,     0x78c06474,
    0xb89ff667,     0xfc57e51d,     0xbc4155d8,     0xfc05a6ed,
    0xbc1df407,     0xf835da29,     0xb836d984,     0x3833580c,
    0x7826cb4b,     0xf86f68e0,     0xb87ae880,     0x3864db0d,
    0x78714888,     0x38a6789b,     0x78bdc9ee,     0x78f6c80f,
    0xb8bdf935,     0xfc6afa9c,     0xbc734943,     0xfc3c5b6c,
    0xbc25fb96,     0xf9189ce5,     0xb91ecafc,     0x39187a13,
    0x791f226c,     0xf95aa2d3,     0xb9587b97,     0x395f7175,
    0x795d9123,     0x399e7de7,     0x799a2697,     0x79df3422,
    0xb99c2604,     0xfd5c2373,     0xbd5fa1b8,     0xfd1d5939,
    0xbd1b1869,     0x58002cfb,     0x1800000a,     0xf8945060,
    0xd8000000,     0xf8ad6b80,     0xf99a0080,     0x1a060034,
    0x3a060088,     0x5a0d0346,     0x7a10009a,     0x9a000360,
    0xba1d030b,     0xda0e0300,     0xfa0302e1,     0x0b340af1,
    0x2b29276c,     0xcb22a9ee,     0x6b2c299d,     0x8b2bce6b,
    0xab2a875d,     0xcb21c8cd,     0xeb3aa47c,     0x3a4c400e,
    0x7a5132a6,     0xba5d622e,     0xfa53814c,     0x3a52d8a2,
    0x7a4d8904,     0xba4b3a8b,     0xfa4d7862,     0x1a95804b,
    0x1a9025f7,     0x5a8fb0c6,     0x5a96974a,     0x9a9cb069,
    0x9a9b374b,     0xda95c12e,     0xda88c6dd,     0x5ac0015d,
    0x5ac005dc,     0x5ac00bbc,     0x5ac01298,     0x5ac01404,
    0xdac002b1,     0xdac005dc,     0xdac00a75,     0xdac00e65,
    0xdac0107d,     0xdac01634,     0x1ac00b0a,     0x1acd0f1a,
    0x1ad021a3,     0x1ad725c7,     0x1ad82a1b,     0x1adb2f22,
    0x9ad90b04,     0x9ad10dda,     0x9acb22a6,     0x9acb2460,
    0x9adb2a1a,     0x9ad12c5b,     0x9bcd7dc9,     0x9b597c4d,
    0x1b0d166e,     0x1b19e48f,     0x9b012c24,     0x9b079a1c,
    0x9b381083,     0x9b23c31a,     0x9bb05b20,     0x9bbcc2ae,
    0x1e22093a,     0x1e3918c0,     0x1e2e28c9,     0x1e2939dc,
    0x1e260a02,     0x1e76096a,     0x1e761b86,     0x1e6a2b4d,
    0x1e77386b,     0x1e6d09cb,     0x1f1b3154,     0x1f17f56a,
    0x1f2831ba,     0x1f2570e9,     0x1f4b2c6e,     0x1f5dc3ae,
    0x1f6e3a91,     0x1f622689,     0x1e2040da,     0x1e20c3bd,
    0x1e214030,     0x1e21c0a2,     0x1e22c069,     0x1e604158,
    0x1e60c026,     0x1e61400b,     0x1e61c223,     0x1e6240bc,
    0x1e3800b6,     0x9e380340,     0x1e780039,     0x9e7800c5,
    0x1e22017b,     0x9e220198,     0x1e6202eb,     0x9e6200f1,
    0x1e2602b0,     0x9e660298,     0x1e270233,     0x9e670382,
    0x1e2722a0,     0x1e7322a0,     0x1e202288,     0x1e602148,
    0x293c15d4,     0x2966387b,     0x69762951,     0xa9041da6,
    0xa9475c0c,     0x29b61ccc,     0x29ee405e,     0x69ee0744,
    0xa9843577,     0xa9f46ebd,     0x28ba16d5,     0x28fc44db,
    0x68f61831,     0xa8b352ac,     0xa8c56d5e,     0x28024144,
    0x2874132e,     0xa8027176,     0xa87b1aa0,     0x0c40732e,
    0x4cdfa176,     0x0cc66ee8,     0x4cdf2733,     0x0d40c21c,
    0x4ddfcaf8,     0x0dd8cca9,     0x4c408d30,     0x0cdf85cb,
    0x4d60c239,     0x0dffcba1,     0x4de8ce2f,     0x4cc24979,
    0x0c404a79,     0x4d40e6ae,     0x4ddfe9b8,     0x0ddcef6d,
    0x4cdf078f,     0x0cc000fa,     0x0d60e217,     0x0dffe720,
    0x0de2eb0b,     0xce648356,     0xce6184c7,     0xcec081d9,
    0xce6d8981,     0xba5fd3e3,     0x3a5f03e5,     0xfa411be4,
    0x7a42cbe2,     0x93df03ff,     0xc820ffff,     0x8822fc7f,
    0xc8247cbf,     0x88267fff,     0x4e010fe0,     0x4e081fe1,
    0x4e0c1fe1,     0x4e0a1fe1,     0x4e071fe1,     0x4cc0ac3f,
    0x05a08020,     0x04b0e3e0,     0x0470e7e1,     0x042f9c20,
    0x043f9c35,     0x047f9c20,     0x04ff9c20,     0x04299420,
    0x04319160,     0x0461943e,     0x04a19020,     0x042053ff,
    0x047f5401,     0x25208028,     0x2538cfe0,     0x2578d001,
    0x25b8efe2,     0x25f8f007,     0xa400a3e0,     0xa4a8a7ea,
    0xa547a814,     0xa4084ffe,     0xa55c53e0,     0xa5e1540b,
    0xe400fbf6,     0xe408ffff,     0xe547e400,     0xe4014be0,
    0xe4a84fe0,     0xe5f15000,     0x858043e0,     0x85a043ff,
    0xe59f5d08,     0x1e601000,     0x1e603000,     0x1e621000,
    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,
    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,
    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,
    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,
    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,
    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,
    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,
    0x1e7e3000,     0xf8388097,     0xf833000f,     0xf8241175,
    0xf83d22af,     0xf82432ee,     0xf83a5165,     0xf82e41cd,
    0xf8287399,     0xf82a6174,     0xf8b181f5,     0xf8b50357,
    0xf8a511e6,     0xf8af21f9,     0xf8bc31f8,     0xf8b9514e,
    0xf8ad428d,     0xf8a173f6,     0xf8ad60c2,     0xf8e38307,
    0xf8e003bb,     0xf8e513a5,     0xf8ea2019,     0xf8ff3260,
    0xf8fc5139,     0xf8f941cb,     0xf8ea722a,     0xf8f86315,
    0xf860814f,     0xf86600bc,     0xf8651285,     0xf873222f,
    0xf87d339a,     0xf861501b,     0xf87441fc,     0xf86c7389,
    0xf87c62d3,     0xb82a83e4,     0xb83403e8,     0xb8331369,
    0xb8222099,     0xb82332c7,     0xb833508c,     0xb83c42b7,
    0xb8397078,     0xb83862fa,     0xb8ae8075,     0xb8b70307,
    0xb8b4120f,     0xb8a22001,     0xb8b83064,     0xb8ab537f,
    0xb8a94059,     0xb8ab73f1,     0xb8a1638c,     0xb8e08171,
    0xb8f00196,     0xb8fb13fd,     0xb8e1237a,     0xb8e4307d,
    0xb8e6533d,     0xb8f140e8,     0xb8ec7280,     0xb8e16058,
    0xb8608308,     0xb87903af,     0xb86312e9,     0xb8692224,
    0xb86130eb,     0xb869520e,     0xb8624169,     0xb86c718e,
    0xb8626286,     0x042401d9,     0x04b00564,     0x65ca020f,
    0x65d80976,     0x65ca05bb,     0x0456afa1,     0x0400044e,
    0x049091ec,     0x04daa143,     0x04d389c5,     0x0411827c,
    0x04901753,     0x0417b899,     0x041eb3b6,     0x04480b4b,
    0x048a17bb,     0x0481059d,     0x04dcb35d,     0x65808d4e,
    0x65cd9de6,     0x65869cda,     0x65c78893,     0x658292af,
    0x04ddaebb,     0x6582b451,     0x6580adc6,     0x65c1b42b,
    0x658da611,     0x6581958e,     0x65eb1f54,     0x65f723a3,
    0x65b94b70,     0x65fd76c6,     0x04505f22,     0x04107056,
    0x04363317,     0x04a33171,     0x046f337c,     0x049a2b65,
    0x045824c6,     0x041934e8,     0x040837bb,     0x044a21fa,
    0x65c738e3,     0x65c63b55,     0x65982096,     0x04412070,

  };
// END  Generated code -- do not edit

  asm_check((unsigned int *)entry, insns, sizeof insns / sizeof insns[0]);

  {
    address PC = __ pc();
    __ ld1(v0, __ T16B, Address(r16));      // No offset
    __ ld1(v0, __ T8H, __ post(r16, 16));   // Post-index
    __ ld2(v0, v1, __ T8H, __ post(r24, 16 * 2));   // Post-index
    __ ld1(v0, __ T16B, __ post(r16, r17)); // Register post-index
    static const unsigned int vector_insns[] = {
       0x4c407200, // ld1   {v0.16b}, [x16]
       0x4cdf7600, // ld1   {v0.8h}, [x16], #16
       0x4cdf8700, // ld2   {v0.8h, v1.8h}, [x24], #32
       0x4cd17200, // ld1   {v0.16b}, [x16], x17
      };
    asm_check((unsigned int *)PC, vector_insns,
              sizeof vector_insns / sizeof vector_insns[0]);
  }
}
#endif // ASSERT

#undef __

void Assembler::emit_data64(jlong data,
                            relocInfo::relocType rtype,
                            int format) {
  if (rtype == relocInfo::none) {
    emit_int64(data);
  } else {
    emit_data64(data, Relocation::spec_simple(rtype), format);
  }
}

void Assembler::emit_data64(jlong data,
                            RelocationHolder const& rspec,
                            int format) {

  assert(inst_mark() != NULL, "must be inside InstructionMark");
  // Do not use AbstractAssembler::relocate, which is not intended for
  // embedded words.  Instead, relocate to the enclosing instruction.
  code_section()->relocate(inst_mark(), rspec, format);
  emit_int64(data);
}

extern "C" {
  void das(uint64_t start, int len) {
    ResourceMark rm;
    len <<= 2;
    if (len < 0)
      Disassembler::decode((address)start + len, (address)start);
    else
      Disassembler::decode((address)start, (address)start + len);
  }

  JNIEXPORT void das1(uintptr_t insn) {
    das(insn, 1);
  }
}

#define gas_assert(ARG1) assert(ARG1, #ARG1)

#define __ as->

void Address::lea(MacroAssembler *as, Register r) const {
  Relocation* reloc = _rspec.reloc();
  relocInfo::relocType rtype = (relocInfo::relocType) reloc->type();

  switch(_mode) {
  case base_plus_offset: {
    if (_offset == 0 && _base == r) // it's a nop
      break;
    if (_offset > 0)
      __ add(r, _base, _offset);
    else
      __ sub(r, _base, -_offset);
      break;
  }
  case base_plus_offset_reg: {
    __ add(r, _base, _index, _ext.op(), MAX2(_ext.shift(), 0));
    break;
  }
  case literal: {
    if (rtype == relocInfo::none)
      __ mov(r, target());
    else
      __ movptr(r, (uint64_t)target());
    break;
  }
  default:
    ShouldNotReachHere();
  }
}

void Assembler::adrp(Register reg1, const Address &dest, uint64_t &byte_offset) {
  ShouldNotReachHere();
}

#undef __

#define starti Instruction_aarch64 do_not_use(this); set_current(&do_not_use)

  void Assembler::adr(Register Rd, address adr) {
    intptr_t offset = adr - pc();
    int offset_lo = offset & 3;
    offset >>= 2;
    starti;
    f(0, 31), f(offset_lo, 30, 29), f(0b10000, 28, 24), sf(offset, 23, 5);
    rf(Rd, 0);
  }

  void Assembler::_adrp(Register Rd, address adr) {
    uint64_t pc_page = (uint64_t)pc() >> 12;
    uint64_t adr_page = (uint64_t)adr >> 12;
    intptr_t offset = adr_page - pc_page;
    int offset_lo = offset & 3;
    offset >>= 2;
    starti;
    f(1, 31), f(offset_lo, 30, 29), f(0b10000, 28, 24), sf(offset, 23, 5);
    rf(Rd, 0);
  }

#undef starti

Address::Address(address target, relocInfo::relocType rtype) : _mode(literal){
  _is_lval = false;
  _target = target;
  switch (rtype) {
  case relocInfo::oop_type:
  case relocInfo::metadata_type:
    // Oops are a special case. Normally they would be their own section
    // but in cases like icBuffer they are literals in the code stream that
    // we don't have a section for. We use none so that we get a literal address
    // which is always patchable.
    break;
  case relocInfo::external_word_type:
    _rspec = external_word_Relocation::spec(target);
    break;
  case relocInfo::internal_word_type:
    _rspec = internal_word_Relocation::spec(target);
    break;
  case relocInfo::opt_virtual_call_type:
    _rspec = opt_virtual_call_Relocation::spec();
    break;
  case relocInfo::static_call_type:
    _rspec = static_call_Relocation::spec();
    break;
  case relocInfo::runtime_call_type:
    _rspec = runtime_call_Relocation::spec();
    break;
  case relocInfo::poll_type:
  case relocInfo::poll_return_type:
    _rspec = Relocation::spec_simple(rtype);
    break;
  case relocInfo::none:
    _rspec = RelocationHolder::none;
    break;
  default:
    ShouldNotReachHere();
    break;
  }
}

void Assembler::b(const Address &dest) {
  code_section()->relocate(pc(), dest.rspec());
  b(dest.target());
}

void Assembler::bl(const Address &dest) {
  code_section()->relocate(pc(), dest.rspec());
  bl(dest.target());
}

void Assembler::adr(Register r, const Address &dest) {
  code_section()->relocate(pc(), dest.rspec());
  adr(r, dest.target());
}

void Assembler::br(Condition cc, Label &L) {
  if (L.is_bound()) {
    br(cc, target(L));
  } else {
    L.add_patch_at(code(), locator());
    br(cc, pc());
  }
}

void Assembler::wrap_label(Label &L,
                                 Assembler::uncond_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L));
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(pc());
  }
}

void Assembler::wrap_label(Register r, Label &L,
                                 compare_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, target(L));
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(r, pc());
  }
}

void Assembler::wrap_label(Register r, int bitpos, Label &L,
                                 test_and_branch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(r, bitpos, target(L));
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(r, bitpos, pc());
  }
}

void Assembler::wrap_label(Label &L, prfop op, prefetch_insn insn) {
  if (L.is_bound()) {
    (this->*insn)(target(L), op);
  } else {
    L.add_patch_at(code(), locator());
    (this->*insn)(pc(), op);
  }
}

// An "all-purpose" add/subtract immediate, per ARM documentation:
// A "programmer-friendly" assembler may accept a negative immediate
// between -(2^24 -1) and -1 inclusive, causing it to convert a
// requested ADD operation to a SUB, or vice versa, and then encode
// the absolute value of the immediate as for uimm24.
void Assembler::add_sub_immediate(Register Rd, Register Rn, unsigned uimm, int op,
                                  int negated_op) {
  bool sets_flags = op & 1;   // this op sets flags
  union {
    unsigned u;
    int imm;
  };
  u = uimm;
  bool shift = false;
  bool neg = imm < 0;
  if (neg) {
    imm = -imm;
    op = negated_op;
  }
  assert(Rd != sp || imm % 16 == 0, "misaligned stack");
  if (imm >= (1 << 11)
      && ((imm >> 12) << 12 == imm)) {
    imm >>= 12;
    shift = true;
  }
  f(op, 31, 29), f(0b10001, 28, 24), f(shift, 23, 22), f(imm, 21, 10);

  // add/subtract immediate ops with the S bit set treat r31 as zr;
  // with S unset they use sp.
  if (sets_flags)
    zrf(Rd, 0);
  else
    srf(Rd, 0);

  srf(Rn, 5);
}

bool Assembler::operand_valid_for_add_sub_immediate(int64_t imm) {
  bool shift = false;
  uint64_t uimm = (uint64_t)uabs((jlong)imm);
  if (uimm < (1 << 12))
    return true;
  if (uimm < (1 << 24)
      && ((uimm >> 12) << 12 == uimm)) {
    return true;
  }
  return false;
}

bool Assembler::operand_valid_for_logical_immediate(bool is32, uint64_t imm) {
  return encode_logical_immediate(is32, imm) != 0xffffffff;
}

static uint64_t doubleTo64Bits(jdouble d) {
  union {
    jdouble double_value;
    uint64_t double_bits;
  };

  double_value = d;
  return double_bits;
}

bool Assembler::operand_valid_for_float_immediate(double imm) {
  // If imm is all zero bits we can use ZR as the source of a
  // floating-point value.
  if (doubleTo64Bits(imm) == 0)
    return true;

  // Otherwise try to encode imm then convert the encoded value back
  // and make sure it's the exact same bit pattern.
  unsigned result = encoding_for_fp_immediate(imm);
  return doubleTo64Bits(imm) == fp_immediate_for_encoding(result, true);
}

int AbstractAssembler::code_fill_byte() {
  return 0;
}

// n.b. this is implemented in subclass MacroAssembler
void Assembler::bang_stack_with_offset(int offset) { Unimplemented(); }


// and now the routines called by the assembler which encapsulate the
// above encode and decode functions

uint32_t
asm_util::encode_logical_immediate(bool is32, uint64_t imm)
{
  if (is32) {
    /* Allow all zeros or all ones in top 32-bits, so that
       constant expressions like ~1 are permitted. */
    if (imm >> 32 != 0 && imm >> 32 != 0xffffffff)
      return 0xffffffff;
    /* Replicate the 32 lower bits to the 32 upper bits.  */
    imm &= 0xffffffff;
    imm |= imm << 32;
  }

  return encoding_for_logical_immediate(imm);
}

unsigned Assembler::pack(double value) {
  float val = (float)value;
  unsigned result = encoding_for_fp_immediate(val);
  guarantee(unpack(result) == value,
            "Invalid floating-point immediate operand");
  return result;
}

// Packed operands for  Floating-point Move (immediate)

static float unpack(unsigned value) {
  union {
    unsigned ival;
    float val;
  };
  ival = fp_immediate_for_encoding(value, 0);
  return val;
}
